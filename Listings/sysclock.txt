; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\sysclock.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\sysclock.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\Inc -I.\System_Files -I.\RTE\_NucleoF446xx -ID:\Users\Laurent\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -ID:\Users\Laurent\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=529 -D_RTE_ -DSTM32F446xx -D_DEBUG -DUSE_HAL_CAN_REGISTER_CALLBACKS --omf_browse=.\objects\sysclock.crf Src\SysClock.c]
                          THUMB

                          AREA ||i.System_Clock_Init||, CODE, READONLY, ALIGN=2

                  System_Clock_Init PROC
;;;28      */
;;;29      void System_Clock_Init(void){
000000  486f              LDR      r0,|L1.448|
;;;30     	
;;;31     // To correctly read data from FLASH memory, the number of wait states (LATENCY)
;;;32     // must be correctly programmed according to the frequency of the CPU clock
;;;33     // (HCLK) and the supply voltage of the device.		
;;;34     	
;;;35     // SEARCH LATENCY IN reference manual FOR DETAILS
;;;36     	
;;;37     	FLASH->ACR &= ~FLASH_ACR_LATENCY;
000002  6800              LDR      r0,[r0,#0]
000004  f020000f          BIC      r0,r0,#0xf
000008  496d              LDR      r1,|L1.448|
00000a  6008              STR      r0,[r1,#0]
;;;38     #if defined(STM32F401xE)
;;;39     	FLASH->ACR |=  FLASH_ACR_LATENCY_2WS;
;;;40     #elif defined(STM32F407xx)
;;;41     	FLASH->ACR |=  FLASH_ACR_LATENCY_5WS;
;;;42     #elif defined(STM32F429xx)
;;;43     	FLASH->ACR |=  FLASH_ACR_LATENCY_7WS;
;;;44     #elif defined(STM32F446xx)
;;;45     	FLASH->ACR |=  FLASH_ACR_LATENCY_5WS;
00000c  4608              MOV      r0,r1
00000e  6800              LDR      r0,[r0,#0]
000010  f0400005          ORR      r0,r0,#5
000014  6008              STR      r0,[r1,#0]
;;;46     #else
;;;47      #error "Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)"
;;;48     #endif
;;;49     	
;;;50     	// Enable the Internal High Speed oscillator 16Mhz (HSI)
;;;51     	RCC->CR |= RCC_CR_HSION;
000016  486b              LDR      r0,|L1.452|
000018  6800              LDR      r0,[r0,#0]
00001a  f0400001          ORR      r0,r0,#1
00001e  4969              LDR      r1,|L1.452|
000020  6008              STR      r0,[r1,#0]
;;;52     	while((RCC->CR & RCC_CR_HSIRDY) == 0);
000022  bf00              NOP      
                  |L1.36|
000024  4867              LDR      r0,|L1.452|
000026  6800              LDR      r0,[r0,#0]
000028  f0000002          AND      r0,r0,#2
00002c  2800              CMP      r0,#0
00002e  d0f9              BEQ      |L1.36|
;;;53     	// Adjusts the Internal High Speed oscillator (HSI) calibration value
;;;54     	// RC oscillator frequencies are factory calibrated by ST for 1 % accuracy at 25oC
;;;55     	// After reset, the factory calibration value is loaded in HSICAL[7:0] of RCC_ICSCR	
;;;56     	RCC->CR &= ~RCC_CR_HSITRIM;
000030  4864              LDR      r0,|L1.452|
000032  6800              LDR      r0,[r0,#0]
000034  f02000f8          BIC      r0,r0,#0xf8
000038  4962              LDR      r1,|L1.452|
00003a  6008              STR      r0,[r1,#0]
;;;57     	RCC->CR |= RCC_CR_HSITRIM_4; // 16; // user-programmable trimming value that is added to  HSITRIM[7:0]not in HSICAL[7:0] !!!
00003c  4608              MOV      r0,r1
00003e  6800              LDR      r0,[r0,#0]
000040  f0400080          ORR      r0,r0,#0x80
000044  6008              STR      r0,[r1,#0]
;;;58     	
;;;59     	RCC->CR    &= ~RCC_CR_PLLON; 
000046  4608              MOV      r0,r1
000048  6800              LDR      r0,[r0,#0]
00004a  f0207080          BIC      r0,r0,#0x1000000
00004e  6008              STR      r0,[r1,#0]
;;;60     	while((RCC->CR & RCC_CR_PLLRDY) == RCC_CR_PLLRDY);
000050  bf00              NOP      
                  |L1.82|
000052  485c              LDR      r0,|L1.452|
000054  6800              LDR      r0,[r0,#0]
000056  f0007000          AND      r0,r0,#0x2000000
00005a  f1b07f00          CMP      r0,#0x2000000
00005e  d0f8              BEQ      |L1.82|
;;;61     	
;;;62     	// Select clock source to PLL
;;;63     	RCC->PLLCFGR &= ~RCC_PLLCFGR_PLLSRC;
000060  4858              LDR      r0,|L1.452|
000062  1d00              ADDS     r0,r0,#4
000064  6800              LDR      r0,[r0,#0]
000066  f4200080          BIC      r0,r0,#0x400000
00006a  4956              LDR      r1,|L1.452|
00006c  1d09              ADDS     r1,r1,#4
00006e  6008              STR      r0,[r1,#0]
;;;64     	RCC->PLLCFGR |= RCC_PLLCFGR_PLLSRC_HSI; // 0 =  HSI, 1 = HSE
000070  4608              MOV      r0,r1
000072  6800              LDR      r0,[r0,#0]
000074  6008              STR      r0,[r1,#0]
;;;65     
;;;66     #if defined(STM32F401xE)
;;;67     	// Make PLL as 84 MHz
;;;68     	
;;;69     //#define RCC_MAX_FREQUENCY            84000000U         /*!< Max frequency of family in Hz*/
;;;70     //#define RCC_MAX_FREQUENCY_SCALE3     60000000U         /*!< Maximum frequency for system clock at power scale3, in Hz */
;;;71     //#define RCC_MAX_FREQUENCY_SCALE2    RCC_MAX_FREQUENCY  /*!< Maximum frequency for system clock at power scale2, in Hz */
;;;72     //#define RCC_PLLVCO_OUTPUT_MIN       192000000U       /*!< Frequency min for PLLVCO output, in Hz */
;;;73     //#define RCC_PLLVCO_INPUT_MIN           950000U       /*!< Frequency min for PLLVCO input, in Hz  */
;;;74     //#define RCC_PLLVCO_INPUT_MAX          2100000U       /*!< Frequency max for PLLVCO input, in Hz  */
;;;75     //#define RCC_PLLVCO_OUTPUT_MAX       432000000U       /*!< Frequency max for PLLVCO output, in Hz */
;;;76     
;;;77     //#define RCC_PLLN_MIN_VALUE                192U
;;;78     //#define RCC_PLLN_MAX_VALUE                432U
;;;79     	
;;;80     	// (192Mhz<VCO clock<432Mhz) & (0.95Mhz<PLL clock input<2.1Mhz)
;;;81     	// f(VCO clock) = f(PLL clock input) * (PLLN / PLLM) = 16MHz * 336/16 = 336 MHz 
;;;82     	// f(PLL_Out) = f(VCO clock) / PLLP = 336MHz/4 = 84MHz (max 84Mhz)  
;;;83     	// f(Peripheral, USB, ..) = f(VCO clock) / PLLQ = 336MHz/7 = 48MHz
;;;84     	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLQ) | 8U <<  RCC_PLLCFGR_PLLQ_Pos;
;;;85     	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLP) | 1U <<  RCC_PLLCFGR_PLLP_Pos;  
;;;86     	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLN) | 168U << RCC_PLLCFGR_PLLN_Pos;
;;;87     	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLM) | 8U <<  RCC_PLLCFGR_PLLM_Pos;
;;;88     	
;;;89     	// Configure the main internal regulator output voltage 
;;;90     	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
;;;91     	PWR->CR |= PWR_CR_VOS;
;;;92     	
;;;93     // The maximum frequency of the AHB, the APB1 and the APB2 domains is 80 MHz.
;;;94     	RCC->CFGR &= ~RCC_CFGR_HPRE;  // AHB prescaler = 1; SYSCLK not divided
;;;95     	RCC->CFGR |= RCC_CFGR_HPRE_DIV;  // AHB prescaler = 1; SYSCLK not divided
;;;96     	RCC->CFGR &= ~RCC_CFGR_PPRE1; // APB high-speed prescaler (APB1) = 1, HCLK not divided
;;;97     	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2; // APB high-speed prescaler (APB1) = 1, HCLK not divided !!!42Mhz max!!!
;;;98     	RCC->CFGR &= ~RCC_CFGR_PPRE2; // APB high-speed prescaler (APB2) = 1, HCLK not divided !!!84Mhz max!!!
;;;99     
;;;100    	SystemCoreClock = 84000000;  // 84
;;;101    	
;;;102    	Apb1PeriphClock = SystemCoreClock / 2; // 42
;;;103    	Apb1TimerClock = Apb1PeriphClock*2; // 84
;;;104    
;;;105    
;;;106    	Apb2PeriphClock = SystemCoreClock / 1; // 84
;;;107    	Apb2TimerClock = Apb2PeriphClock*1;  // 84
;;;108    #elif defined(STM32F407xx)
;;;109    	// Make PLL as 168 MHz
;;;110    
;;;111    //#define RCC_MAX_FREQUENCY           168000000U         /*!< Max frequency of family in Hz*/
;;;112    //#define RCC_MAX_FREQUENCY_SCALE1    RCC_MAX_FREQUENCY  /*!< Maximum frequency for system clock at power scale1, in Hz */
;;;113    //#define RCC_MAX_FREQUENCY_SCALE2    144000000U         /*!< Maximum frequency for system clock at power scale2, in Hz */
;;;114    //#define RCC_PLLVCO_OUTPUT_MIN       100000000U       /*!< Frequency min for PLLVCO output, in Hz */
;;;115    //#define RCC_PLLVCO_INPUT_MIN           950000U       /*!< Frequency min for PLLVCO input, in Hz  */
;;;116    //#define RCC_PLLVCO_INPUT_MAX          2100000U       /*!< Frequency max for PLLVCO input, in Hz  */
;;;117    //#define RCC_PLLVCO_OUTPUT_MAX       432000000U       /*!< Frequency max for PLLVCO output, in Hz */
;;;118    
;;;119    //#define RCC_PLLN_MIN_VALUE                 50U
;;;120    //#define RCC_PLLN_MAX_VALUE                432U
;;;121    
;;;122    	// (100Mhz<VCO clock<432Mhz) & (0.95Mhz<PLL clock input<2.1Mhz)
;;;123    	// f(VCO clock) = f(PLL clock input) * (PLLN / PLLM) = 16MHz * 336/16 = 336 MHz 
;;;124    	// f(PLL_Out) = f(VCO clock) / PLLP = 336MHz/2 = 168MHz (max 168Mhz)  
;;;125    	// f(Peripheral, USB, ..) = f(VCO clock) / PLLQ = 336MHz/8 = 42MHz
;;;126    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLQ) | 8U <<  RCC_PLLCFGR_PLLQ_Pos;
;;;127    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLP) | 0U <<  RCC_PLLCFGR_PLLP_Pos;  
;;;128    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLN) | 336U << RCC_PLLCFGR_PLLN_Pos; 
;;;129    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLM) | 16U <<  RCC_PLLCFGR_PLLM_Pos;
;;;130    
;;;131    // Configure the main internal regulator output voltage 
;;;132    	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
;;;133    	PWR->CR |= PWR_CR_VOS;
;;;134    
;;;135    // The maximum frequency of the AHB=168MHz, the APB1=42MHz and the APB2=84MHz.
;;;136    	RCC->CFGR &= ~RCC_CFGR_HPRE;  // AHB prescaler = 1; SYSCLK not divided
;;;137    	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;  // AHB prescaler = 1; SYSCLK not divided
;;;138    	RCC->CFGR &= ~RCC_CFGR_PPRE1; // APB high-speed prescaler (APB1) = 1, HCLK reset
;;;139    	RCC->CFGR |= RCC_CFGR_PPRE1_DIV4; // APB high-speed prescaler (APB1) = 1, HCLK divided by 4 !!!42Mhz max!!!
;;;140    	RCC->CFGR &= ~RCC_CFGR_PPRE2; // APB high-speed prescaler (APB2) = 1, reset 
;;;141    	RCC->CFGR |= RCC_CFGR_PPRE2_DIV2; // APB high-speed prescaler (APB2) = 1, HCLK fivided by 2 !!!84Mhz max!!!
;;;142    
;;;143    	SystemCoreClock = 168000000;  // 168
;;;144    	
;;;145    	Apb1PeriphClock = SystemCoreClock / 4; // 42
;;;146    	Apb1TimerClock = Apb1PeriphClock*2; // 84
;;;147    
;;;148    
;;;149    	Apb2PeriphClock = SystemCoreClock / 2; // 84
;;;150    	Apb2TimerClock = Apb2PeriphClock*2;  // 168
;;;151    	
;;;152    #elif defined(STM32F429xx)
;;;153    #elif defined(STM32F446xx)
;;;154    // Make PLL as 168 MHz
;;;155    
;;;156    //#define RCC_MAX_FREQUENCY           180000000U         /*!< Max frequency of family in Hz*/
;;;157    //#define RCC_MAX_FREQUENCY_SCALE1    RCC_MAX_FREQUENCY  /*!< Maximum frequency for system clock at power scale1, in Hz */
;;;158    //#define RCC_MAX_FREQUENCY_SCALE2    168000000U         /*!< Maximum frequency for system clock at power scale2, in Hz */
;;;159    //#define RCC_MAX_FREQUENCY_SCALE3    120000000U         /*!< Maximum frequency for system clock at power scale3, in Hz */
;;;160    //#define RCC_PLLVCO_OUTPUT_MIN       100000000U       /*!< Frequency min for PLLVCO output, in Hz */
;;;161    //#define RCC_PLLVCO_INPUT_MIN           950000U       /*!< Frequency min for PLLVCO input, in Hz  */
;;;162    //#define RCC_PLLVCO_INPUT_MAX          2100000U       /*!< Frequency max for PLLVCO input, in Hz  */
;;;163    //#define RCC_PLLVCO_OUTPUT_MAX       432000000U       /*!< Frequency max for PLLVCO output, in Hz */
;;;164    
;;;165    //#define RCC_PLLN_MIN_VALUE                 50U
;;;166    //#define RCC_PLLN_MAX_VALUE                432U
;;;167    	
;;;168    	// (50Mhz<VCO clock<432Mhz) & (0.95Mhz<PLL clock input<2.1Mhz)
;;;169    	// f(VCO clock) = f(PLL clock input) * (PLLN / PLLM) = 16MHz * 180/8 = 360 MHz 
;;;170    	// f(PLL_Out) = f(VCO clock) / PLLP = 360MHz/2 = 180MHz (max 180Mhz)  
;;;171    	// f(Peripheral, USB, ..) = f(VCO clock) / PLLQ = 360MHz/2 = 180MHz
;;;172    
;;;173    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLQ) | 2U <<  RCC_PLLCFGR_PLLQ_Pos; // Q=2
000076  4608              MOV      r0,r1
000078  6800              LDR      r0,[r0,#0]
00007a  f0206070          BIC      r0,r0,#0xf000000
00007e  f0407000          ORR      r0,r0,#0x2000000
000082  6008              STR      r0,[r1,#0]
;;;174    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLP) | 0U <<  RCC_PLLCFGR_PLLP_Pos; // P=2
000084  4608              MOV      r0,r1
000086  6800              LDR      r0,[r0,#0]
000088  f4203040          BIC      r0,r0,#0x30000
00008c  6008              STR      r0,[r1,#0]
;;;175    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLN) | 180U << RCC_PLLCFGR_PLLN_Pos; // N=180
00008e  4608              MOV      r0,r1
000090  6800              LDR      r0,[r0,#0]
000092  f64771c0          MOV      r1,#0x7fc0
000096  4388              BICS     r0,r0,r1
000098  f4405034          ORR      r0,r0,#0x2d00
00009c  4949              LDR      r1,|L1.452|
00009e  1d09              ADDS     r1,r1,#4
0000a0  6008              STR      r0,[r1,#0]
;;;176    	RCC->PLLCFGR = (RCC->PLLCFGR & ~RCC_PLLCFGR_PLLM) | 8U <<  RCC_PLLCFGR_PLLM_Pos; // M=8
0000a2  4608              MOV      r0,r1
0000a4  6800              LDR      r0,[r0,#0]
0000a6  f020003f          BIC      r0,r0,#0x3f
0000aa  f0400008          ORR      r0,r0,#8
0000ae  6008              STR      r0,[r1,#0]
;;;177    	
;;;178    // Configure the main internal regulator output voltage 
;;;179    	RCC->APB1ENR |= RCC_APB1ENR_PWREN;
0000b0  4844              LDR      r0,|L1.452|
0000b2  3040              ADDS     r0,r0,#0x40
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0405080          ORR      r0,r0,#0x10000000
0000ba  4942              LDR      r1,|L1.452|
0000bc  3140              ADDS     r1,r1,#0x40
0000be  6008              STR      r0,[r1,#0]
;;;180    	PWR->CR |= PWR_CR_VOS;
0000c0  4841              LDR      r0,|L1.456|
0000c2  6800              LDR      r0,[r0,#0]
0000c4  f4404040          ORR      r0,r0,#0xc000
0000c8  493f              LDR      r1,|L1.456|
0000ca  6008              STR      r0,[r1,#0]
;;;181    //  enable the Over-drive mode
;;;182    	PWR->CR |= PWR_CR_ODEN;
0000cc  4608              MOV      r0,r1
0000ce  6800              LDR      r0,[r0,#0]
0000d0  f4403080          ORR      r0,r0,#0x10000
0000d4  6008              STR      r0,[r1,#0]
;;;183    	while((PWR->CSR & PWR_CSR_ODRDY) == 0);
0000d6  bf00              NOP      
                  |L1.216|
0000d8  483b              LDR      r0,|L1.456|
0000da  6840              LDR      r0,[r0,#4]
0000dc  f4003080          AND      r0,r0,#0x10000
0000e0  2800              CMP      r0,#0
0000e2  d0f9              BEQ      |L1.216|
;;;184    //  switch the voltage regulator
;;;185    	PWR->CR |= PWR_CR_ODSWEN;
0000e4  4838              LDR      r0,|L1.456|
0000e6  6800              LDR      r0,[r0,#0]
0000e8  f4403000          ORR      r0,r0,#0x20000
0000ec  4936              LDR      r1,|L1.456|
0000ee  6008              STR      r0,[r1,#0]
;;;186    	while((PWR->CSR & PWR_CSR_ODSWRDY) == 0);
0000f0  bf00              NOP      
                  |L1.242|
0000f2  4835              LDR      r0,|L1.456|
0000f4  6840              LDR      r0,[r0,#4]
0000f6  f4003000          AND      r0,r0,#0x20000
0000fa  2800              CMP      r0,#0
0000fc  d0f9              BEQ      |L1.242|
;;;187    // To force APB1 Timer clock to 180Mhz	
;;;188    	RCC->DCKCFGR |= RCC_DCKCFGR_TIMPRE;
0000fe  4831              LDR      r0,|L1.452|
000100  308c              ADDS     r0,r0,#0x8c
000102  6800              LDR      r0,[r0,#0]
000104  f0407080          ORR      r0,r0,#0x1000000
000108  492e              LDR      r1,|L1.452|
00010a  318c              ADDS     r1,r1,#0x8c
00010c  6008              STR      r0,[r1,#0]
;;;189    	
;;;190    // The maximum frequency of the AHB 180 MHz.
;;;191    	RCC->CFGR &= ~RCC_CFGR_HPRE_Msk;  // AHB prescaler = 1; SYSCLK not divided
00010e  482d              LDR      r0,|L1.452|
000110  3008              ADDS     r0,r0,#8
000112  6800              LDR      r0,[r0,#0]
000114  f02000f0          BIC      r0,r0,#0xf0
000118  492a              LDR      r1,|L1.452|
00011a  3108              ADDS     r1,r1,#8
00011c  6008              STR      r0,[r1,#0]
;;;192    	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;  // AHB prescaler = 1; SYSCLK not divided
00011e  4608              MOV      r0,r1
000120  6800              LDR      r0,[r0,#0]
000122  6008              STR      r0,[r1,#0]
;;;193    	
;;;194    	RCC->CFGR &= ~RCC_CFGR_PPRE1_Msk; // APB high-speed prescaler (APB1) = 1, HCLK not divided
000124  4608              MOV      r0,r1
000126  6800              LDR      r0,[r0,#0]
000128  f42050e0          BIC      r0,r0,#0x1c00
00012c  6008              STR      r0,[r1,#0]
;;;195    	RCC->CFGR |= RCC_CFGR_PPRE1_DIV4; // HCLK divide by 4 =42Mhz max (!!! 42Mhz max for I2C !!!)
00012e  4608              MOV      r0,r1
000130  6800              LDR      r0,[r0,#0]
000132  f44050a0          ORR      r0,r0,#0x1400
000136  6008              STR      r0,[r1,#0]
;;;196    	
;;;197    	RCC->CFGR &= ~RCC_CFGR_PPRE2_Msk; // APB high-speed prescaler (APB2) = 1, HCLK not divided 
000138  4608              MOV      r0,r1
00013a  6800              LDR      r0,[r0,#0]
00013c  f4204060          BIC      r0,r0,#0xe000
000140  6008              STR      r0,[r1,#0]
;;;198    	RCC->CFGR |= RCC_CFGR_PPRE2_DIV2; // HCLK divide by 2 =84 Mhz !!!90Mhz max!!!
000142  4608              MOV      r0,r1
000144  6800              LDR      r0,[r0,#0]
000146  f4404000          ORR      r0,r0,#0x8000
00014a  6008              STR      r0,[r1,#0]
;;;199    	
;;;200    	SystemCoreClock = RCC_MAX_FREQUENCY;  // 180
00014c  481f              LDR      r0,|L1.460|
00014e  4920              LDR      r1,|L1.464|
000150  6008              STR      r0,[r1,#0]  ; SystemCoreClock
;;;201    	
;;;202    	Apb1PeriphClock = SystemCoreClock / 4; // 45
000152  4608              MOV      r0,r1
000154  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000156  0880              LSRS     r0,r0,#2
000158  491e              LDR      r1,|L1.468|
00015a  6008              STR      r0,[r1,#0]  ; Apb1PeriphClock
;;;203    	Apb1TimerClock = Apb1PeriphClock*2; // 90
00015c  4608              MOV      r0,r1
00015e  6800              LDR      r0,[r0,#0]  ; Apb1PeriphClock
000160  0040              LSLS     r0,r0,#1
000162  491d              LDR      r1,|L1.472|
000164  6008              STR      r0,[r1,#0]  ; Apb1TimerClock
;;;204    
;;;205    
;;;206    	Apb2PeriphClock = SystemCoreClock / 2; // 90
000166  481a              LDR      r0,|L1.464|
000168  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00016a  0840              LSRS     r0,r0,#1
00016c  491b              LDR      r1,|L1.476|
00016e  6008              STR      r0,[r1,#0]  ; Apb2PeriphClock
;;;207    	Apb2TimerClock = Apb2PeriphClock*2;  // 180
000170  4608              MOV      r0,r1
000172  6800              LDR      r0,[r0,#0]  ; Apb2PeriphClock
000174  0040              LSLS     r0,r0,#1
000176  491a              LDR      r1,|L1.480|
000178  6008              STR      r0,[r1,#0]  ; Apb2TimerClock
;;;208    	
;;;209    #else
;;;210     #error "Please select first the target STM32F4xx device used in your application (in stm32f4xx.h file)"
;;;211    #endif
;;;212    
;;;213    // For debug MCO_1 & MCO_2 : MCO1 = PA8, MCO2 = PC9
;;;214    //	/* Enable GPIOs clock */ 
;;;215    //	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
;;;216    //	RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;
;;;217    //	
;;;218    //	RCC->CFGR &= ~RCC_CFGR_MCO1; // 00: HSI clock selected
;;;219    //	RCC->CFGR &= ~RCC_CFGR_MCO2; // 00: System clock (SYSCLK) selected
;;;220    //	
;;;221    //	RCC->CFGR |= RCC_CFGR_MCO1PRE; // 111: division by 5
;;;222    //	RCC->CFGR |= RCC_CFGR_MCO2PRE; // 111: division by 5
;;;223    //	///////////////////////////////////////////////////////////////////////////////////////////////
;;;224    //	// MCO1 = PA8, MCO2 = PC9
;;;225    //	///////////////////////////////////////////////////////////////////////////////////////////////
;;;226    //	// GPIO Mode: Input(00, reset), Output(01), AlterFunc(10), Analog(11, reset)
;;;227    //	GPIOA->MODER &= ~GPIO_MODER_MODE8; // ~(3U<<(13*2));  // Clear bits
;;;228    //	GPIOA->MODER |= GPIO_MODER_MODE8_1; // AlterFunc(10)
;;;229    //	GPIOA->AFR[1] 	&= ~GPIO_AFRH_AFSEL8; // 0x0001 ;  HIGH:1 LOW:0 // 	AF 1 = TIM1_CH1N
;;;230    //	GPIOA->OTYPER &= ~GPIO_OTYPER_OT8; //~(1U<<2);       // Push-pull
;;;231    //	GPIOA->OSPEEDR &= ~GPIO_OSPEEDR_OSPEED8; //~(3U<<(13*2));
;;;232    //	GPIOA->OSPEEDR |= GPIO_OSPEEDR_OSPEED8; //  3U<<(13*2);  // High speed
;;;233    //	GPIOA->PUPDR   &= ~GPIO_PUPDR_PUPD8; //~(3U<<(13*2));  // No pull-up, no pull-down
;;;234    
;;;235    //	GPIOC->MODER &= ~GPIO_MODER_MODE9; // ~(3U<<(13*2));  // Clear bits
;;;236    //	GPIOC->MODER |= GPIO_MODER_MODE9_1; // AlterFunc(10)
;;;237    //	GPIOC->AFR[1] &= ~GPIO_AFRH_AFSEL9; // 0x0001 ;  HIGH:1 LOW:0 // 	AF 1 = TIM1_CH1N
;;;238    //	GPIOC->OTYPER &= ~GPIO_OTYPER_OT9; //~(1U<<2);       // Push-pull
;;;239    //	GPIOC->OSPEEDR &= ~GPIO_OSPEEDR_OSPEED9; //~(3U<<(13*2));
;;;240    //	GPIOC->OSPEEDR |= GPIO_OSPEEDR_OSPEED9; //  3U<<(13*2);  // High speed
;;;241    //	GPIOC->PUPDR   &= ~GPIO_PUPDR_PUPD9; //~(3U<<(13*2));  // No pull-up, no pull-down
;;;242    
;;;243    	RCC->CR   |= RCC_CR_PLLON; 
00017a  4812              LDR      r0,|L1.452|
00017c  6800              LDR      r0,[r0,#0]
00017e  f0407080          ORR      r0,r0,#0x1000000
000182  4910              LDR      r1,|L1.452|
000184  6008              STR      r0,[r1,#0]
;;;244    	while((RCC->CR & RCC_CR_PLLRDY) == 0);
000186  bf00              NOP      
                  |L1.392|
000188  480e              LDR      r0,|L1.452|
00018a  6800              LDR      r0,[r0,#0]
00018c  f0007000          AND      r0,r0,#0x2000000
000190  2800              CMP      r0,#0
000192  d0f9              BEQ      |L1.392|
;;;245    	
;;;246    	// Select PLL selected as system clock
;;;247    	RCC->CFGR &= ~RCC_CFGR_SW;
000194  480b              LDR      r0,|L1.452|
000196  3008              ADDS     r0,r0,#8
000198  6800              LDR      r0,[r0,#0]
00019a  f0200003          BIC      r0,r0,#3
00019e  4909              LDR      r1,|L1.452|
0001a0  3108              ADDS     r1,r1,#8
0001a2  6008              STR      r0,[r1,#0]
;;;248    	RCC->CFGR |= RCC_CFGR_SW_PLL; // 00: HSI, 01:HSE, 10: PLL, 11: Not allowed
0001a4  4608              MOV      r0,r1
0001a6  6800              LDR      r0,[r0,#0]
0001a8  f0400002          ORR      r0,r0,#2
0001ac  6008              STR      r0,[r1,#0]
;;;249    	
;;;250    	// Wait until System Clock has been selected
;;;251    	while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
0001ae  bf00              NOP      
                  |L1.432|
0001b0  4804              LDR      r0,|L1.452|
0001b2  3008              ADDS     r0,r0,#8
0001b4  6800              LDR      r0,[r0,#0]
0001b6  f000000c          AND      r0,r0,#0xc
0001ba  2808              CMP      r0,#8
0001bc  d1f8              BNE      |L1.432|
;;;252    
;;;253    }
0001be  4770              BX       lr
                          ENDP

                  |L1.448|
                          DCD      0x40023c00
                  |L1.452|
                          DCD      0x40023800
                  |L1.456|
                          DCD      0x40007000
                  |L1.460|
                          DCD      0x0aba9500
                  |L1.464|
                          DCD      SystemCoreClock
                  |L1.468|
                          DCD      Apb1PeriphClock
                  |L1.472|
                          DCD      Apb1TimerClock
                  |L1.476|
                          DCD      Apb2PeriphClock
                  |L1.480|
                          DCD      Apb2TimerClock

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x00000000
                  Apb1TimerClock
                          DCD      0x00000000
                  Apb2TimerClock
                          DCD      0x00000000
                  Apb1PeriphClock
                          DCD      0x00000000
                  Apb2PeriphClock
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Src\\SysClock.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_SysClock_c_5d646a67____REV16|
#line 492 "D:\\Users\\Laurent\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___10_SysClock_c_5d646a67____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_SysClock_c_5d646a67____REVSH|
#line 507
|__asm___10_SysClock_c_5d646a67____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___10_SysClock_c_5d646a67____RRX|
#line 694
|__asm___10_SysClock_c_5d646a67____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
