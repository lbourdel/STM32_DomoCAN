; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\stm32f4xx_hal_can.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\stm32f4xx_hal_can.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\Inc -I.\System_Files -I.\RTE\_NucleoF446xx -ID:\Users\Laurent\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -ID:\Users\Laurent\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=529 -D_RTE_ -DSTM32F446xx -D_DEBUG -DUSE_HAL_CAN_REGISTER_CALLBACKS --omf_browse=.\objects\stm32f4xx_hal_can.crf Src\stm32f4xx_hal_can.c]
                          THUMB

                          AREA ||i.HAL_CAN_AbortTxRequest||, CODE, READONLY, ALIGN=2

                  HAL_CAN_AbortTxRequest PROC
;;;1360     */
;;;1361   HAL_StatusTypeDef HAL_CAN_AbortTxRequest(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)
000000  b570              PUSH     {r4-r6,lr}
;;;1362   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1363     HAL_CAN_StateTypeDef state = hcan->State;
000006  f8946020          LDRB     r6,[r4,#0x20]
;;;1364   
;;;1365     /* Check function parameters */
;;;1366     assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));
00000a  2d07              CMP      r5,#7
00000c  d800              BHI      |L1.16|
00000e  e004              B        |L1.26|
                  |L1.16|
000010  f2405156          MOV      r1,#0x556
000014  a014              ADR      r0,|L1.104|
000016  f7fffffe          BL       assert_failed
                  |L1.26|
;;;1367   
;;;1368     if ((state == HAL_CAN_STATE_READY) ||
00001a  2e01              CMP      r6,#1
00001c  d001              BEQ      |L1.34|
;;;1369         (state == HAL_CAN_STATE_LISTENING))
00001e  2e02              CMP      r6,#2
000020  d11c              BNE      |L1.92|
                  |L1.34|
;;;1370     {
;;;1371       /* Check Tx Mailbox 0 */
;;;1372       if ((TxMailboxes & CAN_TX_MAILBOX0) != 0U)
000022  f0050001          AND      r0,r5,#1
000026  b128              CBZ      r0,|L1.52|
;;;1373       {
;;;1374         /* Add cancellation request for Tx Mailbox 0 */
;;;1375         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ0);
000028  6820              LDR      r0,[r4,#0]
00002a  6880              LDR      r0,[r0,#8]
00002c  f0400080          ORR      r0,r0,#0x80
000030  6821              LDR      r1,[r4,#0]
000032  6088              STR      r0,[r1,#8]
                  |L1.52|
;;;1376       }
;;;1377   
;;;1378       /* Check Tx Mailbox 1 */
;;;1379       if ((TxMailboxes & CAN_TX_MAILBOX1) != 0U)
000034  f0050002          AND      r0,r5,#2
000038  b128              CBZ      r0,|L1.70|
;;;1380       {
;;;1381         /* Add cancellation request for Tx Mailbox 1 */
;;;1382         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ1);
00003a  6820              LDR      r0,[r4,#0]
00003c  6880              LDR      r0,[r0,#8]
00003e  f4404000          ORR      r0,r0,#0x8000
000042  6821              LDR      r1,[r4,#0]
000044  6088              STR      r0,[r1,#8]
                  |L1.70|
;;;1383       }
;;;1384   
;;;1385       /* Check Tx Mailbox 2 */
;;;1386       if ((TxMailboxes & CAN_TX_MAILBOX2) != 0U)
000046  f0050004          AND      r0,r5,#4
00004a  b128              CBZ      r0,|L1.88|
;;;1387       {
;;;1388         /* Add cancellation request for Tx Mailbox 2 */
;;;1389         SET_BIT(hcan->Instance->TSR, CAN_TSR_ABRQ2);
00004c  6820              LDR      r0,[r4,#0]
00004e  6880              LDR      r0,[r0,#8]
000050  f4400000          ORR      r0,r0,#0x800000
000054  6821              LDR      r1,[r4,#0]
000056  6088              STR      r0,[r1,#8]
                  |L1.88|
;;;1390       }
;;;1391   
;;;1392       /* Return function status */
;;;1393       return HAL_OK;
000058  2000              MOVS     r0,#0
                  |L1.90|
;;;1394     }
;;;1395     else
;;;1396     {
;;;1397       /* Update error code */
;;;1398       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1399   
;;;1400       return HAL_ERROR;
;;;1401     }
;;;1402   }
00005a  bd70              POP      {r4-r6,pc}
                  |L1.92|
00005c  6a60              LDR      r0,[r4,#0x24]         ;1398
00005e  f4402080          ORR      r0,r0,#0x40000        ;1398
000062  6260              STR      r0,[r4,#0x24]         ;1398
000064  2001              MOVS     r0,#1                 ;1400
000066  e7f8              B        |L1.90|
;;;1403   
                          ENDP

                  |L1.104|
000068  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
00006c  73746d33
000070  32663478
000074  785f6861
000078  6c5f6361
00007c  6e2e6300

                          AREA ||i.HAL_CAN_ActivateNotification||, CODE, READONLY, ALIGN=2

                  HAL_CAN_ActivateNotification PROC
;;;1661     */
;;;1662   HAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs)
000000  b570              PUSH     {r4-r6,lr}
;;;1663   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1664     HAL_CAN_StateTypeDef state = hcan->State;
000006  f8946020          LDRB     r6,[r4,#0x20]
;;;1665   
;;;1666     /* Check function parameters */
;;;1667     assert_param(IS_CAN_IT(ActiveITs));
00000a  480d              LDR      r0,|L2.64|
00000c  4285              CMP      r5,r0
00000e  d800              BHI      |L2.18|
000010  e004              B        |L2.28|
                  |L2.18|
000012  f2406183          MOV      r1,#0x683
000016  a00b              ADR      r0,|L2.68|
000018  f7fffffe          BL       assert_failed
                  |L2.28|
;;;1668   
;;;1669     if ((state == HAL_CAN_STATE_READY) ||
00001c  2e01              CMP      r6,#1
00001e  d001              BEQ      |L2.36|
;;;1670         (state == HAL_CAN_STATE_LISTENING))
000020  2e02              CMP      r6,#2
000022  d106              BNE      |L2.50|
                  |L2.36|
;;;1671     {
;;;1672       /* Enable the selected interrupts */
;;;1673       __HAL_CAN_ENABLE_IT(hcan, ActiveITs);
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  4328              ORRS     r0,r0,r5
00002a  6821              LDR      r1,[r4,#0]
00002c  6148              STR      r0,[r1,#0x14]
;;;1674   
;;;1675       /* Return function status */
;;;1676       return HAL_OK;
00002e  2000              MOVS     r0,#0
                  |L2.48|
;;;1677     }
;;;1678     else
;;;1679     {
;;;1680       /* Update error code */
;;;1681       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1682   
;;;1683       return HAL_ERROR;
;;;1684     }
;;;1685   }
000030  bd70              POP      {r4-r6,pc}
                  |L2.50|
000032  6a60              LDR      r0,[r4,#0x24]         ;1681
000034  f4402080          ORR      r0,r0,#0x40000        ;1681
000038  6260              STR      r0,[r4,#0x24]         ;1681
00003a  2001              MOVS     r0,#1                 ;1683
00003c  e7f8              B        |L2.48|
;;;1686   
                          ENDP

00003e  0000              DCW      0x0000
                  |L2.64|
                          DCD      0x00038f7f
                  |L2.68|
000044  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
000048  73746d33
00004c  32663478
000050  785f6861
000054  6c5f6361
000058  6e2e6300

                          AREA ||i.HAL_CAN_AddTxMessage||, CODE, READONLY, ALIGN=2

                  HAL_CAN_AddTxMessage PROC
;;;1252     */
;;;1253   HAL_StatusTypeDef HAL_CAN_AddTxMessage(CAN_HandleTypeDef *hcan, CAN_TxHeaderTypeDef *pHeader, uint8_t aData[], uint32_t *pTxMailbox)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1254   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
000008  4617              MOV      r7,r2
00000a  4699              MOV      r9,r3
;;;1255     uint32_t transmitmailbox;
;;;1256     HAL_CAN_StateTypeDef state = hcan->State;
00000c  f895a020          LDRB     r10,[r5,#0x20]
;;;1257     uint32_t tsr = READ_REG(hcan->Instance->TSR);
000010  6828              LDR      r0,[r5,#0]
000012  f8d08008          LDR      r8,[r0,#8]
;;;1258   
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_CAN_IDTYPE(pHeader->IDE));
000016  68a0              LDR      r0,[r4,#8]
000018  b110              CBZ      r0,|L3.32|
00001a  68a0              LDR      r0,[r4,#8]
00001c  2804              CMP      r0,#4
00001e  d100              BNE      |L3.34|
                  |L3.32|
000020  e004              B        |L3.44|
                  |L3.34|
000022  f24041ec          MOV      r1,#0x4ec
000026  a063              ADR      r0,|L3.436|
000028  f7fffffe          BL       assert_failed
                  |L3.44|
;;;1261     assert_param(IS_CAN_RTR(pHeader->RTR));
00002c  68e0              LDR      r0,[r4,#0xc]
00002e  b110              CBZ      r0,|L3.54|
000030  68e0              LDR      r0,[r4,#0xc]
000032  2802              CMP      r0,#2
000034  d100              BNE      |L3.56|
                  |L3.54|
000036  e004              B        |L3.66|
                  |L3.56|
000038  f24041ed          MOV      r1,#0x4ed
00003c  a05d              ADR      r0,|L3.436|
00003e  f7fffffe          BL       assert_failed
                  |L3.66|
;;;1262     assert_param(IS_CAN_DLC(pHeader->DLC));
000042  6920              LDR      r0,[r4,#0x10]
000044  2808              CMP      r0,#8
000046  d800              BHI      |L3.74|
000048  e004              B        |L3.84|
                  |L3.74|
00004a  f24041ee          MOV      r1,#0x4ee
00004e  a059              ADR      r0,|L3.436|
000050  f7fffffe          BL       assert_failed
                  |L3.84|
;;;1263     if (pHeader->IDE == CAN_ID_STD)
000054  68a0              LDR      r0,[r4,#8]
000056  b950              CBNZ     r0,|L3.110|
;;;1264     {
;;;1265       assert_param(IS_CAN_STDID(pHeader->StdId));
000058  6820              LDR      r0,[r4,#0]
00005a  f5b06f00          CMP      r0,#0x800
00005e  d200              BCS      |L3.98|
000060  e00f              B        |L3.130|
                  |L3.98|
000062  f24041f1          MOV      r1,#0x4f1
000066  a053              ADR      r0,|L3.436|
000068  f7fffffe          BL       assert_failed
00006c  e009              B        |L3.130|
                  |L3.110|
;;;1266     }
;;;1267     else
;;;1268     {
;;;1269       assert_param(IS_CAN_EXTID(pHeader->ExtId));
00006e  6860              LDR      r0,[r4,#4]
000070  f1b05f00          CMP      r0,#0x20000000
000074  d200              BCS      |L3.120|
000076  e004              B        |L3.130|
                  |L3.120|
000078  f24041f5          MOV      r1,#0x4f5
00007c  a04d              ADR      r0,|L3.436|
00007e  f7fffffe          BL       assert_failed
                  |L3.130|
;;;1270     }
;;;1271     assert_param(IS_FUNCTIONAL_STATE(pHeader->TransmitGlobalTime));
000082  7d20              LDRB     r0,[r4,#0x14]
000084  b110              CBZ      r0,|L3.140|
000086  7d20              LDRB     r0,[r4,#0x14]
000088  2801              CMP      r0,#1
00008a  d100              BNE      |L3.142|
                  |L3.140|
00008c  e004              B        |L3.152|
                  |L3.142|
00008e  f24041f7          MOV      r1,#0x4f7
000092  a048              ADR      r0,|L3.436|
000094  f7fffffe          BL       assert_failed
                  |L3.152|
;;;1272   
;;;1273     if ((state == HAL_CAN_STATE_READY) ||
000098  f1ba0f01          CMP      r10,#1
00009c  d002              BEQ      |L3.164|
;;;1274         (state == HAL_CAN_STATE_LISTENING))
00009e  f1ba0f02          CMP      r10,#2
0000a2  d179              BNE      |L3.408|
                  |L3.164|
;;;1275     {
;;;1276       /* Check that all the Tx mailboxes are not full */
;;;1277       if (((tsr & CAN_TSR_TME0) != 0U) ||
0000a4  f0086080          AND      r0,r8,#0x4000000
0000a8  b930              CBNZ     r0,|L3.184|
;;;1278           ((tsr & CAN_TSR_TME1) != 0U) ||
0000aa  f0086000          AND      r0,r8,#0x8000000
0000ae  b918              CBNZ     r0,|L3.184|
;;;1279           ((tsr & CAN_TSR_TME2) != 0U))
0000b0  f0085080          AND      r0,r8,#0x10000000
0000b4  2800              CMP      r0,#0
0000b6  d071              BEQ      |L3.412|
                  |L3.184|
;;;1280       {
;;;1281         /* Select an empty transmit mailbox */
;;;1282         transmitmailbox = (tsr & CAN_TSR_CODE) >> CAN_TSR_CODE_Pos;
0000b8  f3c86601          UBFX     r6,r8,#24,#2
;;;1283   
;;;1284         /* Check transmit mailbox value */
;;;1285         if (transmitmailbox > 2U)
0000bc  2e02              CMP      r6,#2
0000be  d906              BLS      |L3.206|
;;;1286         {
;;;1287           /* Update error code */
;;;1288           hcan->ErrorCode |= HAL_CAN_ERROR_INTERNAL;
0000c0  6a68              LDR      r0,[r5,#0x24]
0000c2  f4400000          ORR      r0,r0,#0x800000
0000c6  6268              STR      r0,[r5,#0x24]
;;;1289   
;;;1290           return HAL_ERROR;
0000c8  2001              MOVS     r0,#1
                  |L3.202|
;;;1291         }
;;;1292   
;;;1293         /* Store the Tx mailbox */
;;;1294         *pTxMailbox = (uint32_t)1 << transmitmailbox;
;;;1295   
;;;1296         /* Set up the Id */
;;;1297         if (pHeader->IDE == CAN_ID_STD)
;;;1298         {
;;;1299           hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->StdId << CAN_TI0R_STID_Pos) |
;;;1300                                                              pHeader->RTR);
;;;1301         }
;;;1302         else
;;;1303         {
;;;1304           hcan->Instance->sTxMailBox[transmitmailbox].TIR = ((pHeader->ExtId << CAN_TI0R_EXID_Pos) |
;;;1305                                                              pHeader->IDE |
;;;1306                                                              pHeader->RTR);
;;;1307         }
;;;1308   
;;;1309         /* Set up the DLC */
;;;1310         hcan->Instance->sTxMailBox[transmitmailbox].TDTR = (pHeader->DLC);
;;;1311   
;;;1312         /* Set up the Transmit Global Time mode */
;;;1313         if (pHeader->TransmitGlobalTime == ENABLE)
;;;1314         {
;;;1315           SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TDTR, CAN_TDT0R_TGT);
;;;1316         }
;;;1317   
;;;1318         /* Set up the data field */
;;;1319         WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDHR,
;;;1320                   ((uint32_t)aData[7] << CAN_TDH0R_DATA7_Pos) |
;;;1321                   ((uint32_t)aData[6] << CAN_TDH0R_DATA6_Pos) |
;;;1322                   ((uint32_t)aData[5] << CAN_TDH0R_DATA5_Pos) |
;;;1323                   ((uint32_t)aData[4] << CAN_TDH0R_DATA4_Pos));
;;;1324         WRITE_REG(hcan->Instance->sTxMailBox[transmitmailbox].TDLR,
;;;1325                   ((uint32_t)aData[3] << CAN_TDL0R_DATA3_Pos) |
;;;1326                   ((uint32_t)aData[2] << CAN_TDL0R_DATA2_Pos) |
;;;1327                   ((uint32_t)aData[1] << CAN_TDL0R_DATA1_Pos) |
;;;1328                   ((uint32_t)aData[0] << CAN_TDL0R_DATA0_Pos));
;;;1329   
;;;1330         /* Request transmission */
;;;1331         SET_BIT(hcan->Instance->sTxMailBox[transmitmailbox].TIR, CAN_TI0R_TXRQ);
;;;1332   
;;;1333         /* Return function status */
;;;1334         return HAL_OK;
;;;1335       }
;;;1336       else
;;;1337       {
;;;1338         /* Update error code */
;;;1339         hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
;;;1340   
;;;1341         return HAL_ERROR;
;;;1342       }
;;;1343     }
;;;1344     else
;;;1345     {
;;;1346       /* Update error code */
;;;1347       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1348   
;;;1349       return HAL_ERROR;
;;;1350     }
;;;1351   }
0000ca  e8bd87f0          POP      {r4-r10,pc}
                  |L3.206|
0000ce  2001              MOVS     r0,#1                 ;1294
0000d0  40b0              LSLS     r0,r0,r6              ;1294
0000d2  f8c90000          STR      r0,[r9,#0]            ;1294
0000d6  68a0              LDR      r0,[r4,#8]            ;1297
0000d8  b950              CBNZ     r0,|L3.240|
0000da  8821              LDRH     r1,[r4,#0]            ;1299
0000dc  68e0              LDR      r0,[r4,#0xc]          ;1299
0000de  ea405141          ORR      r1,r0,r1,LSL #21      ;1299
0000e2  6828              LDR      r0,[r5,#0]            ;1299
0000e4  f50070c0          ADD      r0,r0,#0x180          ;1299
0000e8  eb001006          ADD      r0,r0,r6,LSL #4       ;1299
0000ec  6001              STR      r1,[r0,#0]            ;1299
0000ee  e00b              B        |L3.264|
                  |L3.240|
0000f0  e9d41001          LDRD     r1,r0,[r4,#4]         ;1304
0000f4  ea4000c1          ORR      r0,r0,r1,LSL #3       ;1304
0000f8  68e1              LDR      r1,[r4,#0xc]          ;1304
0000fa  4308              ORRS     r0,r0,r1              ;1304
0000fc  6829              LDR      r1,[r5,#0]            ;1304
0000fe  f50171c0          ADD      r1,r1,#0x180          ;1304
000102  eb011106          ADD      r1,r1,r6,LSL #4       ;1304
000106  6008              STR      r0,[r1,#0]            ;1304
                  |L3.264|
000108  6921              LDR      r1,[r4,#0x10]         ;1310
00010a  6828              LDR      r0,[r5,#0]            ;1310
00010c  f50070c0          ADD      r0,r0,#0x180          ;1310
000110  eb001006          ADD      r0,r0,r6,LSL #4       ;1310
000114  6041              STR      r1,[r0,#4]            ;1310
000116  7d20              LDRB     r0,[r4,#0x14]         ;1313
000118  2801              CMP      r0,#1                 ;1313
00011a  d10d              BNE      |L3.312|
00011c  6828              LDR      r0,[r5,#0]            ;1315
00011e  f50070c0          ADD      r0,r0,#0x180          ;1315
000122  eb001006          ADD      r0,r0,r6,LSL #4       ;1315
000126  6840              LDR      r0,[r0,#4]            ;1315
000128  f4407180          ORR      r1,r0,#0x100          ;1315
00012c  6828              LDR      r0,[r5,#0]            ;1315
00012e  f50070c0          ADD      r0,r0,#0x180          ;1315
000132  eb001006          ADD      r0,r0,r6,LSL #4       ;1315
000136  6041              STR      r1,[r0,#4]            ;1315
                  |L3.312|
000138  79f8              LDRB     r0,[r7,#7]            ;1319
00013a  0600              LSLS     r0,r0,#24             ;1319
00013c  79b9              LDRB     r1,[r7,#6]            ;1319
00013e  ea404001          ORR      r0,r0,r1,LSL #16      ;1319
000142  7979              LDRB     r1,[r7,#5]            ;1319
000144  ea402001          ORR      r0,r0,r1,LSL #8       ;1319
000148  7939              LDRB     r1,[r7,#4]            ;1319
00014a  4308              ORRS     r0,r0,r1              ;1319
00014c  6829              LDR      r1,[r5,#0]            ;1319
00014e  f50171c0          ADD      r1,r1,#0x180          ;1319
000152  eb011106          ADD      r1,r1,r6,LSL #4       ;1319
000156  60c8              STR      r0,[r1,#0xc]          ;1319
000158  78f8              LDRB     r0,[r7,#3]            ;1324
00015a  0600              LSLS     r0,r0,#24             ;1324
00015c  78b9              LDRB     r1,[r7,#2]            ;1324
00015e  ea404001          ORR      r0,r0,r1,LSL #16      ;1324
000162  7879              LDRB     r1,[r7,#1]            ;1324
000164  ea402001          ORR      r0,r0,r1,LSL #8       ;1324
000168  7839              LDRB     r1,[r7,#0]            ;1324
00016a  4308              ORRS     r0,r0,r1              ;1324
00016c  6829              LDR      r1,[r5,#0]            ;1324
00016e  f50171c0          ADD      r1,r1,#0x180          ;1324
000172  eb011106          ADD      r1,r1,r6,LSL #4       ;1324
000176  6088              STR      r0,[r1,#8]            ;1324
000178  6828              LDR      r0,[r5,#0]            ;1331
00017a  f50070c0          ADD      r0,r0,#0x180          ;1331
00017e  eb001006          ADD      r0,r0,r6,LSL #4       ;1331
000182  6800              LDR      r0,[r0,#0]            ;1331
000184  f0400101          ORR      r1,r0,#1              ;1331
000188  6828              LDR      r0,[r5,#0]            ;1331
00018a  f50070c0          ADD      r0,r0,#0x180          ;1331
00018e  eb001006          ADD      r0,r0,r6,LSL #4       ;1331
000192  6001              STR      r1,[r0,#0]            ;1331
000194  2000              MOVS     r0,#0                 ;1334
000196  e798              B        |L3.202|
                  |L3.408|
000198  e006              B        |L3.424|
00019a  e7ff              B        |L3.412|
                  |L3.412|
00019c  6a68              LDR      r0,[r5,#0x24]         ;1339
00019e  f4401000          ORR      r0,r0,#0x200000       ;1339
0001a2  6268              STR      r0,[r5,#0x24]         ;1339
0001a4  2001              MOVS     r0,#1                 ;1341
0001a6  e790              B        |L3.202|
                  |L3.424|
0001a8  6a68              LDR      r0,[r5,#0x24]         ;1347
0001aa  f4402080          ORR      r0,r0,#0x40000        ;1347
0001ae  6268              STR      r0,[r5,#0x24]         ;1347
0001b0  2001              MOVS     r0,#1                 ;1349
0001b2  e78a              B        |L3.202|
;;;1352   
                          ENDP

                  |L3.436|
0001b4  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
0001b8  73746d33
0001bc  32663478
0001c0  785f6861
0001c4  6c5f6361
0001c8  6e2e6300

                          AREA ||i.HAL_CAN_ConfigFilter||, CODE, READONLY, ALIGN=2

                  HAL_CAN_ConfigFilter PROC
;;;840      */
;;;841    HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;842    {
000004  4607              MOV      r7,r0
000006  460c              MOV      r4,r1
;;;843      uint32_t filternbrbitpos;
;;;844      CAN_TypeDef *can_ip = hcan->Instance;
000008  683d              LDR      r5,[r7,#0]
;;;845      HAL_CAN_StateTypeDef state = hcan->State;
00000a  f8978020          LDRB     r8,[r7,#0x20]
;;;846    
;;;847      if ((state == HAL_CAN_STATE_READY) ||
00000e  f1b80f01          CMP      r8,#1
000012  d002              BEQ      |L4.26|
;;;848          (state == HAL_CAN_STATE_LISTENING))
000014  f1b80f02          CMP      r8,#2
000018  d17e              BNE      |L4.280|
                  |L4.26|
;;;849      {
;;;850        /* Check the parameters */
;;;851        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdHigh));
00001a  6820              LDR      r0,[r4,#0]
00001c  f5b03f80          CMP      r0,#0x10000
000020  d200              BCS      |L4.36|
000022  e004              B        |L4.46|
                  |L4.36|
000024  f2403153          MOV      r1,#0x353
000028  a072              ADR      r0,|L4.500|
00002a  f7fffffe          BL       assert_failed
                  |L4.46|
;;;852        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterIdLow));
00002e  6860              LDR      r0,[r4,#4]
000030  f5b03f80          CMP      r0,#0x10000
000034  d200              BCS      |L4.56|
000036  e004              B        |L4.66|
                  |L4.56|
000038  f44f7155          MOV      r1,#0x354
00003c  a06d              ADR      r0,|L4.500|
00003e  f7fffffe          BL       assert_failed
                  |L4.66|
;;;853        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdHigh));
000042  68a0              LDR      r0,[r4,#8]
000044  f5b03f80          CMP      r0,#0x10000
000048  d200              BCS      |L4.76|
00004a  e004              B        |L4.86|
                  |L4.76|
00004c  f2403155          MOV      r1,#0x355
000050  a068              ADR      r0,|L4.500|
000052  f7fffffe          BL       assert_failed
                  |L4.86|
;;;854        assert_param(IS_CAN_FILTER_ID_HALFWORD(sFilterConfig->FilterMaskIdLow));
000056  68e0              LDR      r0,[r4,#0xc]
000058  f5b03f80          CMP      r0,#0x10000
00005c  d200              BCS      |L4.96|
00005e  e004              B        |L4.106|
                  |L4.96|
000060  f2403156          MOV      r1,#0x356
000064  a063              ADR      r0,|L4.500|
000066  f7fffffe          BL       assert_failed
                  |L4.106|
;;;855        assert_param(IS_CAN_FILTER_MODE(sFilterConfig->FilterMode));
00006a  69a0              LDR      r0,[r4,#0x18]
00006c  b110              CBZ      r0,|L4.116|
00006e  69a0              LDR      r0,[r4,#0x18]
000070  2801              CMP      r0,#1
000072  d100              BNE      |L4.118|
                  |L4.116|
000074  e004              B        |L4.128|
                  |L4.118|
000076  f2403157          MOV      r1,#0x357
00007a  a05e              ADR      r0,|L4.500|
00007c  f7fffffe          BL       assert_failed
                  |L4.128|
;;;856        assert_param(IS_CAN_FILTER_SCALE(sFilterConfig->FilterScale));
000080  69e0              LDR      r0,[r4,#0x1c]
000082  b110              CBZ      r0,|L4.138|
000084  69e0              LDR      r0,[r4,#0x1c]
000086  2801              CMP      r0,#1
000088  d100              BNE      |L4.140|
                  |L4.138|
00008a  e004              B        |L4.150|
                  |L4.140|
00008c  f44f7156          MOV      r1,#0x358
000090  a058              ADR      r0,|L4.500|
000092  f7fffffe          BL       assert_failed
                  |L4.150|
;;;857        assert_param(IS_CAN_FILTER_FIFO(sFilterConfig->FilterFIFOAssignment));
000096  6920              LDR      r0,[r4,#0x10]
000098  b110              CBZ      r0,|L4.160|
00009a  6920              LDR      r0,[r4,#0x10]
00009c  2801              CMP      r0,#1
00009e  d100              BNE      |L4.162|
                  |L4.160|
0000a0  e004              B        |L4.172|
                  |L4.162|
0000a2  f2403159          MOV      r1,#0x359
0000a6  a053              ADR      r0,|L4.500|
0000a8  f7fffffe          BL       assert_failed
                  |L4.172|
;;;858        assert_param(IS_CAN_FILTER_ACTIVATION(sFilterConfig->FilterActivation));
0000ac  6a20              LDR      r0,[r4,#0x20]
0000ae  b110              CBZ      r0,|L4.182|
0000b0  6a20              LDR      r0,[r4,#0x20]
0000b2  2801              CMP      r0,#1
0000b4  d100              BNE      |L4.184|
                  |L4.182|
0000b6  e004              B        |L4.194|
                  |L4.184|
0000b8  f240315a          MOV      r1,#0x35a
0000bc  a04d              ADR      r0,|L4.500|
0000be  f7fffffe          BL       assert_failed
                  |L4.194|
;;;859    
;;;860    #if defined(CAN3)
;;;861        /* Check the CAN instance */
;;;862        if (hcan->Instance == CAN3)
;;;863        {
;;;864          /* CAN3 is single instance with 14 dedicated filters banks */
;;;865    
;;;866          /* Check the parameters */
;;;867          assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
;;;868        }
;;;869        else
;;;870        {
;;;871          /* CAN1 and CAN2 are dual instances with 28 common filters banks */
;;;872          /* Select master instance to access the filter banks */
;;;873          can_ip = CAN1;
;;;874    
;;;875          /* Check the parameters */
;;;876          assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->FilterBank));
;;;877          assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->SlaveStartFilterBank));
;;;878        }
;;;879    #elif defined(CAN2)
;;;880        /* CAN1 and CAN2 are dual instances with 28 common filters banks */
;;;881        /* Select master instance to access the filter banks */
;;;882        can_ip = CAN1;
0000c2  4d52              LDR      r5,|L4.524|
;;;883    
;;;884        /* Check the parameters */
;;;885        assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->FilterBank));
0000c4  6960              LDR      r0,[r4,#0x14]
0000c6  281b              CMP      r0,#0x1b
0000c8  d800              BHI      |L4.204|
0000ca  e004              B        |L4.214|
                  |L4.204|
0000cc  f2403175          MOV      r1,#0x375
0000d0  a048              ADR      r0,|L4.500|
0000d2  f7fffffe          BL       assert_failed
                  |L4.214|
;;;886        assert_param(IS_CAN_FILTER_BANK_DUAL(sFilterConfig->SlaveStartFilterBank));
0000d6  6a60              LDR      r0,[r4,#0x24]
0000d8  281b              CMP      r0,#0x1b
0000da  d800              BHI      |L4.222|
0000dc  e004              B        |L4.232|
                  |L4.222|
0000de  f2403176          MOV      r1,#0x376
0000e2  a044              ADR      r0,|L4.500|
0000e4  f7fffffe          BL       assert_failed
                  |L4.232|
;;;887    #else
;;;888        /* CAN1 is single instance with 14 dedicated filters banks */
;;;889    
;;;890        /* Check the parameters */
;;;891        assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
;;;892    #endif
;;;893    
;;;894        /* Initialisation mode for the filter */
;;;895        SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
0000e8  f5057500          ADD      r5,r5,#0x200
0000ec  6828              LDR      r0,[r5,#0]
0000ee  f0400001          ORR      r0,r0,#1
0000f2  6028              STR      r0,[r5,#0]
;;;896    
;;;897    #if defined(CAN3)
;;;898        /* Check the CAN instance */
;;;899        if (can_ip == CAN1)
;;;900        {
;;;901          /* Select the start filter number of CAN2 slave instance */
;;;902          CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
;;;903          SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
;;;904        }
;;;905    
;;;906    #elif defined(CAN2)
;;;907        /* Select the start filter number of CAN2 slave instance */
;;;908        CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
0000f4  6828              LDR      r0,[r5,#0]
0000f6  f420507c          BIC      r0,r0,#0x3f00
0000fa  6028              STR      r0,[r5,#0]
;;;909        SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);
0000fc  6828              LDR      r0,[r5,#0]
0000fe  6a61              LDR      r1,[r4,#0x24]
000100  ea402001          ORR      r0,r0,r1,LSL #8
000104  6028              STR      r0,[r5,#0]
;;;910    
;;;911    #endif
;;;912        /* Convert filter number into bit position */
;;;913        filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
000106  7d20              LDRB     r0,[r4,#0x14]
000108  f000011f          AND      r1,r0,#0x1f
00010c  2001              MOVS     r0,#1
00010e  fa00f601          LSL      r6,r0,r1
;;;914    
;;;915        /* Filter Deactivation */
;;;916        CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
000112  69e8              LDR      r0,[r5,#0x1c]
000114  43b0              BICS     r0,r0,r6
000116  e000              B        |L4.282|
                  |L4.280|
000118  e066              B        |L4.488|
                  |L4.282|
00011a  61e8              STR      r0,[r5,#0x1c]
00011c  f5a57500          SUB      r5,r5,#0x200
;;;917    
;;;918        /* Filter Scale */
;;;919        if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
000120  69e0              LDR      r0,[r4,#0x1c]
000122  b9c8              CBNZ     r0,|L4.344|
;;;920        {
;;;921          /* 16-bit scale for the filter */
;;;922          CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
000124  f8d5020c          LDR      r0,[r5,#0x20c]
000128  43b0              BICS     r0,r0,r6
00012a  f8c5020c          STR      r0,[r5,#0x20c]
;;;923    
;;;924          /* First 16-bit identifier and First 16-bit mask */
;;;925          /* Or First 16-bit identifier and Second 16-bit identifier */
;;;926          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
00012e  88a0              LDRH     r0,[r4,#4]
000130  b280              UXTH     r0,r0
000132  89a1              LDRH     r1,[r4,#0xc]
000134  ea404101          ORR      r1,r0,r1,LSL #16
000138  f5057010          ADD      r0,r5,#0x240
00013c  6962              LDR      r2,[r4,#0x14]
00013e  f8401032          STR      r1,[r0,r2,LSL #3]
;;;927            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
;;;928            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
;;;929    
;;;930          /* Second 16-bit identifier and Second 16-bit mask */
;;;931          /* Or Third 16-bit identifier and Fourth 16-bit identifier */
;;;932          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
000142  8820              LDRH     r0,[r4,#0]
000144  b280              UXTH     r0,r0
000146  8921              LDRH     r1,[r4,#8]
000148  ea404101          ORR      r1,r0,r1,LSL #16
00014c  f5057010          ADD      r0,r5,#0x240
000150  6962              LDR      r2,[r4,#0x14]
000152  eb0000c2          ADD      r0,r0,r2,LSL #3
000156  6041              STR      r1,[r0,#4]
                  |L4.344|
;;;933            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
;;;934            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
;;;935        }
;;;936    
;;;937        if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
000158  69e0              LDR      r0,[r4,#0x1c]
00015a  2801              CMP      r0,#1
00015c  d119              BNE      |L4.402|
;;;938        {
;;;939          /* 32-bit scale for the filter */
;;;940          SET_BIT(can_ip->FS1R, filternbrbitpos);
00015e  f8d5020c          LDR      r0,[r5,#0x20c]
000162  4330              ORRS     r0,r0,r6
000164  f8c5020c          STR      r0,[r5,#0x20c]
;;;941    
;;;942          /* 32-bit identifier or First 32-bit identifier */
;;;943          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
000168  88a0              LDRH     r0,[r4,#4]
00016a  b280              UXTH     r0,r0
00016c  8821              LDRH     r1,[r4,#0]
00016e  ea404101          ORR      r1,r0,r1,LSL #16
000172  f5057010          ADD      r0,r5,#0x240
000176  6962              LDR      r2,[r4,#0x14]
000178  f8401032          STR      r1,[r0,r2,LSL #3]
;;;944            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
;;;945            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
;;;946    
;;;947          /* 32-bit mask or Second 32-bit identifier */
;;;948          can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
00017c  89a0              LDRH     r0,[r4,#0xc]
00017e  b280              UXTH     r0,r0
000180  8921              LDRH     r1,[r4,#8]
000182  ea404101          ORR      r1,r0,r1,LSL #16
000186  f5057010          ADD      r0,r5,#0x240
00018a  6962              LDR      r2,[r4,#0x14]
00018c  eb0000c2          ADD      r0,r0,r2,LSL #3
000190  6041              STR      r1,[r0,#4]
                  |L4.402|
;;;949            ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
;;;950            (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
;;;951        }
;;;952    
;;;953        /* Filter Mode */
;;;954        if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
000192  69a0              LDR      r0,[r4,#0x18]
000194  b928              CBNZ     r0,|L4.418|
;;;955        {
;;;956          /* Id/Mask mode for the filter*/
;;;957          CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
000196  f8d50204          LDR      r0,[r5,#0x204]
00019a  43b0              BICS     r0,r0,r6
00019c  f8c50204          STR      r0,[r5,#0x204]
0001a0  e004              B        |L4.428|
                  |L4.418|
;;;958        }
;;;959        else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
;;;960        {
;;;961          /* Identifier list mode for the filter*/
;;;962          SET_BIT(can_ip->FM1R, filternbrbitpos);
0001a2  f8d50204          LDR      r0,[r5,#0x204]
0001a6  4330              ORRS     r0,r0,r6
0001a8  f8c50204          STR      r0,[r5,#0x204]
                  |L4.428|
;;;963        }
;;;964    
;;;965        /* Filter FIFO assignment */
;;;966        if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
0001ac  6920              LDR      r0,[r4,#0x10]
0001ae  b928              CBNZ     r0,|L4.444|
;;;967        {
;;;968          /* FIFO 0 assignation for the filter */
;;;969          CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
0001b0  f8d50214          LDR      r0,[r5,#0x214]
0001b4  43b0              BICS     r0,r0,r6
0001b6  f8c50214          STR      r0,[r5,#0x214]
0001ba  e004              B        |L4.454|
                  |L4.444|
;;;970        }
;;;971        else
;;;972        {
;;;973          /* FIFO 1 assignation for the filter */
;;;974          SET_BIT(can_ip->FFA1R, filternbrbitpos);
0001bc  f8d50214          LDR      r0,[r5,#0x214]
0001c0  4330              ORRS     r0,r0,r6
0001c2  f8c50214          STR      r0,[r5,#0x214]
                  |L4.454|
;;;975        }
;;;976    
;;;977        /* Filter activation */
;;;978        if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
0001c6  6a20              LDR      r0,[r4,#0x20]
0001c8  2801              CMP      r0,#1
0001ca  d104              BNE      |L4.470|
;;;979        {
;;;980          SET_BIT(can_ip->FA1R, filternbrbitpos);
0001cc  f8d5021c          LDR      r0,[r5,#0x21c]
0001d0  4330              ORRS     r0,r0,r6
0001d2  f8c5021c          STR      r0,[r5,#0x21c]
                  |L4.470|
;;;981        }
;;;982    
;;;983        /* Leave the initialisation mode for the filter */
;;;984        CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
0001d6  f8d50200          LDR      r0,[r5,#0x200]
0001da  f0200001          BIC      r0,r0,#1
0001de  f8c50200          STR      r0,[r5,#0x200]
;;;985    
;;;986        /* Return function status */
;;;987        return HAL_OK;
0001e2  2000              MOVS     r0,#0
                  |L4.484|
;;;988      }
;;;989      else
;;;990      {
;;;991        /* Update error code */
;;;992        hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;993    
;;;994        return HAL_ERROR;
;;;995      }
;;;996    }
0001e4  e8bd81f0          POP      {r4-r8,pc}
                  |L4.488|
0001e8  6a78              LDR      r0,[r7,#0x24]         ;992
0001ea  f4402080          ORR      r0,r0,#0x40000        ;992
0001ee  6278              STR      r0,[r7,#0x24]         ;992
0001f0  2001              MOVS     r0,#1                 ;994
0001f2  e7f7              B        |L4.484|
;;;997    
                          ENDP

                  |L4.500|
0001f4  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
0001f8  73746d33
0001fc  32663478
000200  785f6861
000204  6c5f6361
000208  6e2e6300
                  |L4.524|
                          DCD      0x40006400

                          AREA ||i.HAL_CAN_DeInit||, CODE, READONLY, ALIGN=2

                  HAL_CAN_DeInit PROC
;;;461      */
;;;462    HAL_StatusTypeDef HAL_CAN_DeInit(CAN_HandleTypeDef *hcan)
000000  b510              PUSH     {r4,lr}
;;;463    {
000002  4604              MOV      r4,r0
;;;464      /* Check CAN handle */
;;;465      if (hcan == NULL)
000004  b90c              CBNZ     r4,|L5.10|
;;;466      {
;;;467        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L5.8|
;;;468      }
;;;469    
;;;470      /* Check the parameters */
;;;471    // LBR  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;472    
;;;473      /* Stop the CAN module */
;;;474      (void)HAL_CAN_Stop(hcan);
;;;475    
;;;476    #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;477      if (hcan->MspDeInitCallback == NULL)
;;;478      {
;;;479        hcan->MspDeInitCallback = HAL_CAN_MspDeInit; /* Legacy weak MspDeInit */
;;;480      }
;;;481    
;;;482      /* DeInit the low level hardware: CLOCK, NVIC */
;;;483      hcan->MspDeInitCallback(hcan);
;;;484    
;;;485    #else
;;;486      /* DeInit the low level hardware: CLOCK, NVIC */
;;;487      HAL_CAN_MspDeInit(hcan);
;;;488    #endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
;;;489    
;;;490      /* Reset the CAN peripheral */
;;;491      SET_BIT(hcan->Instance->MCR, CAN_MCR_RESET);
;;;492    
;;;493      /* Reset the CAN ErrorCode */
;;;494      hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;495    
;;;496      /* Change CAN state */
;;;497      hcan->State = HAL_CAN_STATE_RESET;
;;;498    
;;;499      /* Return function status */
;;;500      return HAL_OK;
;;;501    }
000008  bd10              POP      {r4,pc}
                  |L5.10|
00000a  4620              MOV      r0,r4                 ;474
00000c  f7fffffe          BL       HAL_CAN_Stop
000010  6e20              LDR      r0,[r4,#0x60]         ;477
000012  b908              CBNZ     r0,|L5.24|
000014  4808              LDR      r0,|L5.56|
000016  6620              STR      r0,[r4,#0x60]         ;479
                  |L5.24|
000018  4620              MOV      r0,r4                 ;483
00001a  6e21              LDR      r1,[r4,#0x60]         ;483
00001c  4788              BLX      r1                    ;483
00001e  6820              LDR      r0,[r4,#0]            ;491
000020  6800              LDR      r0,[r0,#0]            ;491
000022  f4404000          ORR      r0,r0,#0x8000         ;491
000026  6821              LDR      r1,[r4,#0]            ;491
000028  6008              STR      r0,[r1,#0]            ;491
00002a  2000              MOVS     r0,#0                 ;494
00002c  6260              STR      r0,[r4,#0x24]         ;494
00002e  f8840020          STRB     r0,[r4,#0x20]         ;497
000032  bf00              NOP                            ;500
000034  e7e8              B        |L5.8|
;;;502    
                          ENDP

000036  0000              DCW      0x0000
                  |L5.56|
                          DCD      HAL_CAN_MspDeInit

                          AREA ||i.HAL_CAN_DeactivateNotification||, CODE, READONLY, ALIGN=2

                  HAL_CAN_DeactivateNotification PROC
;;;1694     */
;;;1695   HAL_StatusTypeDef HAL_CAN_DeactivateNotification(CAN_HandleTypeDef *hcan, uint32_t InactiveITs)
000000  b570              PUSH     {r4-r6,lr}
;;;1696   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1697     HAL_CAN_StateTypeDef state = hcan->State;
000006  f8946020          LDRB     r6,[r4,#0x20]
;;;1698   
;;;1699     /* Check function parameters */
;;;1700     assert_param(IS_CAN_IT(InactiveITs));
00000a  480d              LDR      r0,|L6.64|
00000c  4285              CMP      r5,r0
00000e  d800              BHI      |L6.18|
000010  e004              B        |L6.28|
                  |L6.18|
000012  f24061a4          MOV      r1,#0x6a4
000016  a00b              ADR      r0,|L6.68|
000018  f7fffffe          BL       assert_failed
                  |L6.28|
;;;1701   
;;;1702     if ((state == HAL_CAN_STATE_READY) ||
00001c  2e01              CMP      r6,#1
00001e  d001              BEQ      |L6.36|
;;;1703         (state == HAL_CAN_STATE_LISTENING))
000020  2e02              CMP      r6,#2
000022  d106              BNE      |L6.50|
                  |L6.36|
;;;1704     {
;;;1705       /* Disable the selected interrupts */
;;;1706       __HAL_CAN_DISABLE_IT(hcan, InactiveITs);
000024  6820              LDR      r0,[r4,#0]
000026  6940              LDR      r0,[r0,#0x14]
000028  43a8              BICS     r0,r0,r5
00002a  6821              LDR      r1,[r4,#0]
00002c  6148              STR      r0,[r1,#0x14]
;;;1707   
;;;1708       /* Return function status */
;;;1709       return HAL_OK;
00002e  2000              MOVS     r0,#0
                  |L6.48|
;;;1710     }
;;;1711     else
;;;1712     {
;;;1713       /* Update error code */
;;;1714       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1715   
;;;1716       return HAL_ERROR;
;;;1717     }
;;;1718   }
000030  bd70              POP      {r4-r6,pc}
                  |L6.50|
000032  6a60              LDR      r0,[r4,#0x24]         ;1714
000034  f4402080          ORR      r0,r0,#0x40000        ;1714
000038  6260              STR      r0,[r4,#0x24]         ;1714
00003a  2001              MOVS     r0,#1                 ;1716
00003c  e7f8              B        |L6.48|
;;;1719   
                          ENDP

00003e  0000              DCW      0x0000
                  |L6.64|
                          DCD      0x00038f7f
                  |L6.68|
000044  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
000048  73746d33
00004c  32663478
000050  785f6861
000054  6c5f6361
000058  6e2e6300

                          AREA ||i.HAL_CAN_ErrorCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ErrorCallback PROC
;;;2339     */
;;;2340   __weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2341   {
;;;2342     /* Prevent unused argument(s) compilation warning */
;;;2343     UNUSED(hcan);
;;;2344   
;;;2345     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2346               the HAL_CAN_ErrorCallback could be implemented in the user file
;;;2347      */
;;;2348   }
;;;2349   
                          ENDP


                          AREA ||i.HAL_CAN_GetError||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetError PROC
;;;2411     */
;;;2412   uint32_t HAL_CAN_GetError(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;2413   {
;;;2414     /* Return CAN error code */
;;;2415     return hcan->ErrorCode;
000002  6a48              LDR      r0,[r1,#0x24]
;;;2416   }
000004  4770              BX       lr
;;;2417   
                          ENDP


                          AREA ||i.HAL_CAN_GetRxFifoFillLevel||, CODE, READONLY, ALIGN=2

                  HAL_CAN_GetRxFifoFillLevel PROC
;;;1608     */
;;;1609   uint32_t HAL_CAN_GetRxFifoFillLevel(CAN_HandleTypeDef *hcan, uint32_t RxFifo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1610   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1611     uint32_t filllevel = 0U;
000008  2700              MOVS     r7,#0
;;;1612     HAL_CAN_StateTypeDef state = hcan->State;
00000a  f8946020          LDRB     r6,[r4,#0x20]
;;;1613   
;;;1614     /* Check function parameters */
;;;1615     assert_param(IS_CAN_RX_FIFO(RxFifo));
00000e  b10d              CBZ      r5,|L9.20|
000010  2d01              CMP      r5,#1
000012  d100              BNE      |L9.22|
                  |L9.20|
000014  e004              B        |L9.32|
                  |L9.22|
000016  f240614f          MOV      r1,#0x64f
00001a  a00a              ADR      r0,|L9.68|
00001c  f7fffffe          BL       assert_failed
                  |L9.32|
;;;1616   
;;;1617     if ((state == HAL_CAN_STATE_READY) ||
000020  2e01              CMP      r6,#1
000022  d001              BEQ      |L9.40|
;;;1618         (state == HAL_CAN_STATE_LISTENING))
000024  2e02              CMP      r6,#2
000026  d109              BNE      |L9.60|
                  |L9.40|
;;;1619     {
;;;1620       if (RxFifo == CAN_RX_FIFO0)
000028  b925              CBNZ     r5,|L9.52|
;;;1621       {
;;;1622         filllevel = hcan->Instance->RF0R & CAN_RF0R_FMP0;
00002a  6820              LDR      r0,[r4,#0]
00002c  68c0              LDR      r0,[r0,#0xc]
00002e  f0000703          AND      r7,r0,#3
000032  e003              B        |L9.60|
                  |L9.52|
;;;1623       }
;;;1624       else /* RxFifo == CAN_RX_FIFO1 */
;;;1625       {
;;;1626         filllevel = hcan->Instance->RF1R & CAN_RF1R_FMP1;
000034  6820              LDR      r0,[r4,#0]
000036  6900              LDR      r0,[r0,#0x10]
000038  f0000703          AND      r7,r0,#3
                  |L9.60|
;;;1627       }
;;;1628     }
;;;1629   
;;;1630     /* Return Rx FIFO fill level */
;;;1631     return filllevel;
00003c  4638              MOV      r0,r7
;;;1632   }
00003e  e8bd81f0          POP      {r4-r8,pc}
;;;1633   
                          ENDP

000042  0000              DCW      0x0000
                  |L9.68|
000044  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
000048  73746d33
00004c  32663478
000050  785f6861
000054  6c5f6361
000058  6e2e6300

                          AREA ||i.HAL_CAN_GetRxMessage||, CODE, READONLY, ALIGN=2

                  HAL_CAN_GetRxMessage PROC
;;;1518     */
;;;1519   HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1520   {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;1521     HAL_CAN_StateTypeDef state = hcan->State;
00000c  f8948020          LDRB     r8,[r4,#0x20]
;;;1522   
;;;1523     assert_param(IS_CAN_RX_FIFO(RxFifo));
000010  b10d              CBZ      r5,|L10.22|
000012  2d01              CMP      r5,#1
000014  d100              BNE      |L10.24|
                  |L10.22|
000016  e004              B        |L10.34|
                  |L10.24|
000018  f24051f3          MOV      r1,#0x5f3
00001c  a05f              ADR      r0,|L10.412|
00001e  f7fffffe          BL       assert_failed
                  |L10.34|
;;;1524   
;;;1525     if ((state == HAL_CAN_STATE_READY) ||
000022  f1b80f01          CMP      r8,#1
000026  d002              BEQ      |L10.46|
;;;1526         (state == HAL_CAN_STATE_LISTENING))
000028  f1b80f02          CMP      r8,#2
00002c  d17d              BNE      |L10.298|
                  |L10.46|
;;;1527     {
;;;1528       /* Check the Rx FIFO */
;;;1529       if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
00002e  b95d              CBNZ     r5,|L10.72|
;;;1530       {
;;;1531         /* Check that the Rx FIFO 0 is not empty */
;;;1532         if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
000030  6820              LDR      r0,[r4,#0]
000032  68c0              LDR      r0,[r0,#0xc]
000034  f0000003          AND      r0,r0,#3
000038  b988              CBNZ     r0,|L10.94|
;;;1533         {
;;;1534           /* Update error code */
;;;1535           hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
00003a  6a60              LDR      r0,[r4,#0x24]
00003c  f4401000          ORR      r0,r0,#0x200000
000040  6260              STR      r0,[r4,#0x24]
;;;1536   
;;;1537           return HAL_ERROR;
000042  2001              MOVS     r0,#1
                  |L10.68|
;;;1538         }
;;;1539       }
;;;1540       else /* Rx element is assigned to Rx FIFO 1 */
;;;1541       {
;;;1542         /* Check that the Rx FIFO 1 is not empty */
;;;1543         if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
;;;1544         {
;;;1545           /* Update error code */
;;;1546           hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
;;;1547   
;;;1548           return HAL_ERROR;
;;;1549         }
;;;1550       }
;;;1551   
;;;1552       /* Get the header */
;;;1553       pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
;;;1554       if (pHeader->IDE == CAN_ID_STD)
;;;1555       {
;;;1556         pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
;;;1557       }
;;;1558       else
;;;1559       {
;;;1560         pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
;;;1561       }
;;;1562       pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_RTR_Pos;
;;;1563       pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
;;;1564       pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
;;;1565       pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
;;;1566   
;;;1567       /* Get the data */
;;;1568       aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
;;;1569       aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
;;;1570       aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
;;;1571       aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
;;;1572       aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
;;;1573       aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
;;;1574       aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
;;;1575       aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
;;;1576   
;;;1577       /* Release the FIFO */
;;;1578       if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
;;;1579       {
;;;1580         /* Release RX FIFO 0 */
;;;1581         SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
;;;1582       }
;;;1583       else /* Rx element is assigned to Rx FIFO 1 */
;;;1584       {
;;;1585         /* Release RX FIFO 1 */
;;;1586         SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
;;;1587       }
;;;1588   
;;;1589       /* Return function status */
;;;1590       return HAL_OK;
;;;1591     }
;;;1592     else
;;;1593     {
;;;1594       /* Update error code */
;;;1595       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1596   
;;;1597       return HAL_ERROR;
;;;1598     }
;;;1599   }
000044  e8bd81f0          POP      {r4-r8,pc}
                  |L10.72|
000048  6820              LDR      r0,[r4,#0]            ;1543
00004a  6900              LDR      r0,[r0,#0x10]         ;1543
00004c  f0000003          AND      r0,r0,#3              ;1543
000050  b928              CBNZ     r0,|L10.94|
000052  6a60              LDR      r0,[r4,#0x24]         ;1546
000054  f4401000          ORR      r0,r0,#0x200000       ;1546
000058  6260              STR      r0,[r4,#0x24]         ;1546
00005a  2001              MOVS     r0,#1                 ;1548
00005c  e7f2              B        |L10.68|
                  |L10.94|
00005e  6820              LDR      r0,[r4,#0]            ;1553
000060  f50070d8          ADD      r0,r0,#0x1b0          ;1553
000064  eb001005          ADD      r0,r0,r5,LSL #4       ;1553
000068  6800              LDR      r0,[r0,#0]            ;1553
00006a  f0000004          AND      r0,r0,#4              ;1553
00006e  60b0              STR      r0,[r6,#8]            ;1553
000070  68b0              LDR      r0,[r6,#8]            ;1554
000072  b940              CBNZ     r0,|L10.134|
000074  6820              LDR      r0,[r4,#0]            ;1556
000076  f50070d8          ADD      r0,r0,#0x1b0          ;1556
00007a  eb001005          ADD      r0,r0,r5,LSL #4       ;1556
00007e  6800              LDR      r0,[r0,#0]            ;1556
000080  0d40              LSRS     r0,r0,#21             ;1556
000082  6030              STR      r0,[r6,#0]            ;1556
000084  e007              B        |L10.150|
                  |L10.134|
000086  6820              LDR      r0,[r4,#0]            ;1560
000088  f50070d8          ADD      r0,r0,#0x1b0          ;1560
00008c  eb001005          ADD      r0,r0,r5,LSL #4       ;1560
000090  6800              LDR      r0,[r0,#0]            ;1560
000092  08c0              LSRS     r0,r0,#3              ;1560
000094  6070              STR      r0,[r6,#4]            ;1560
                  |L10.150|
000096  6820              LDR      r0,[r4,#0]            ;1562
000098  f50070d8          ADD      r0,r0,#0x1b0          ;1562
00009c  eb001005          ADD      r0,r0,r5,LSL #4       ;1562
0000a0  6800              LDR      r0,[r0,#0]            ;1562
0000a2  f0000002          AND      r0,r0,#2              ;1562
0000a6  0840              LSRS     r0,r0,#1              ;1562
0000a8  60f0              STR      r0,[r6,#0xc]          ;1562
0000aa  6820              LDR      r0,[r4,#0]            ;1563
0000ac  f50070d8          ADD      r0,r0,#0x1b0          ;1563
0000b0  eb001005          ADD      r0,r0,r5,LSL #4       ;1563
0000b4  6840              LDR      r0,[r0,#4]            ;1563
0000b6  f000000f          AND      r0,r0,#0xf            ;1563
0000ba  6130              STR      r0,[r6,#0x10]         ;1563
0000bc  6820              LDR      r0,[r4,#0]            ;1564
0000be  f50070d8          ADD      r0,r0,#0x1b0          ;1564
0000c2  eb001005          ADD      r0,r0,r5,LSL #4       ;1564
0000c6  6840              LDR      r0,[r0,#4]            ;1564
0000c8  f400407f          AND      r0,r0,#0xff00         ;1564
0000cc  0a00              LSRS     r0,r0,#8              ;1564
0000ce  61b0              STR      r0,[r6,#0x18]         ;1564
0000d0  6820              LDR      r0,[r4,#0]            ;1565
0000d2  f50070d8          ADD      r0,r0,#0x1b0          ;1565
0000d6  eb001005          ADD      r0,r0,r5,LSL #4       ;1565
0000da  6840              LDR      r0,[r0,#4]            ;1565
0000dc  0c00              LSRS     r0,r0,#16             ;1565
0000de  6170              STR      r0,[r6,#0x14]         ;1565
0000e0  6820              LDR      r0,[r4,#0]            ;1568
0000e2  f50070d8          ADD      r0,r0,#0x1b0          ;1568
0000e6  eb001005          ADD      r0,r0,r5,LSL #4       ;1568
0000ea  6880              LDR      r0,[r0,#8]            ;1568
0000ec  7038              STRB     r0,[r7,#0]            ;1568
0000ee  6820              LDR      r0,[r4,#0]            ;1569
0000f0  f50070d8          ADD      r0,r0,#0x1b0          ;1569
0000f4  eb001005          ADD      r0,r0,r5,LSL #4       ;1569
0000f8  6880              LDR      r0,[r0,#8]            ;1569
0000fa  f400407f          AND      r0,r0,#0xff00         ;1569
0000fe  0a00              LSRS     r0,r0,#8              ;1569
000100  7078              STRB     r0,[r7,#1]            ;1569
000102  6820              LDR      r0,[r4,#0]            ;1570
000104  f50070d8          ADD      r0,r0,#0x1b0          ;1570
000108  eb001005          ADD      r0,r0,r5,LSL #4       ;1570
00010c  6880              LDR      r0,[r0,#8]            ;1570
00010e  f400007f          AND      r0,r0,#0xff0000       ;1570
000112  0c00              LSRS     r0,r0,#16             ;1570
000114  70b8              STRB     r0,[r7,#2]            ;1570
000116  6820              LDR      r0,[r4,#0]            ;1571
000118  f50070d8          ADD      r0,r0,#0x1b0          ;1571
00011c  eb001005          ADD      r0,r0,r5,LSL #4       ;1571
000120  6880              LDR      r0,[r0,#8]            ;1571
000122  0e00              LSRS     r0,r0,#24             ;1571
000124  70f8              STRB     r0,[r7,#3]            ;1571
000126  6820              LDR      r0,[r4,#0]            ;1572
000128  e000              B        |L10.300|
                  |L10.298|
00012a  e031              B        |L10.400|
                  |L10.300|
00012c  f50070d8          ADD      r0,r0,#0x1b0          ;1572
000130  eb001005          ADD      r0,r0,r5,LSL #4       ;1572
000134  68c0              LDR      r0,[r0,#0xc]          ;1572
000136  7138              STRB     r0,[r7,#4]            ;1572
000138  6820              LDR      r0,[r4,#0]            ;1573
00013a  f50070d8          ADD      r0,r0,#0x1b0          ;1573
00013e  eb001005          ADD      r0,r0,r5,LSL #4       ;1573
000142  68c0              LDR      r0,[r0,#0xc]          ;1573
000144  f400407f          AND      r0,r0,#0xff00         ;1573
000148  0a00              LSRS     r0,r0,#8              ;1573
00014a  7178              STRB     r0,[r7,#5]            ;1573
00014c  6820              LDR      r0,[r4,#0]            ;1574
00014e  f50070d8          ADD      r0,r0,#0x1b0          ;1574
000152  eb001005          ADD      r0,r0,r5,LSL #4       ;1574
000156  68c0              LDR      r0,[r0,#0xc]          ;1574
000158  f400007f          AND      r0,r0,#0xff0000       ;1574
00015c  0c00              LSRS     r0,r0,#16             ;1574
00015e  71b8              STRB     r0,[r7,#6]            ;1574
000160  6820              LDR      r0,[r4,#0]            ;1575
000162  f50070d8          ADD      r0,r0,#0x1b0          ;1575
000166  eb001005          ADD      r0,r0,r5,LSL #4       ;1575
00016a  68c0              LDR      r0,[r0,#0xc]          ;1575
00016c  0e00              LSRS     r0,r0,#24             ;1575
00016e  71f8              STRB     r0,[r7,#7]            ;1575
000170  b935              CBNZ     r5,|L10.384|
000172  6820              LDR      r0,[r4,#0]            ;1581
000174  68c0              LDR      r0,[r0,#0xc]          ;1581
000176  f0400020          ORR      r0,r0,#0x20           ;1581
00017a  6821              LDR      r1,[r4,#0]            ;1581
00017c  60c8              STR      r0,[r1,#0xc]          ;1581
00017e  e005              B        |L10.396|
                  |L10.384|
000180  6820              LDR      r0,[r4,#0]            ;1586
000182  6900              LDR      r0,[r0,#0x10]         ;1586
000184  f0400020          ORR      r0,r0,#0x20           ;1586
000188  6821              LDR      r1,[r4,#0]            ;1586
00018a  6108              STR      r0,[r1,#0x10]         ;1586
                  |L10.396|
00018c  2000              MOVS     r0,#0                 ;1590
00018e  e759              B        |L10.68|
                  |L10.400|
000190  6a60              LDR      r0,[r4,#0x24]         ;1595
000192  f4402080          ORR      r0,r0,#0x40000        ;1595
000196  6260              STR      r0,[r4,#0x24]         ;1595
000198  2001              MOVS     r0,#1                 ;1597
00019a  e753              B        |L10.68|
;;;1600   
                          ENDP

                  |L10.412|
00019c  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
0001a0  73746d33
0001a4  32663478
0001a8  785f6861
0001ac  6c5f6361
0001b0  6e2e6300

                          AREA ||i.HAL_CAN_GetState||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetState PROC
;;;2376     */
;;;2377   HAL_CAN_StateTypeDef HAL_CAN_GetState(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;2378   {
;;;2379     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8910020          LDRB     r0,[r1,#0x20]
;;;2380   
;;;2381     if ((state == HAL_CAN_STATE_READY) ||
000006  2801              CMP      r0,#1
000008  d001              BEQ      |L11.14|
;;;2382         (state == HAL_CAN_STATE_LISTENING))
00000a  2802              CMP      r0,#2
00000c  d10c              BNE      |L11.40|
                  |L11.14|
;;;2383     {
;;;2384       /* Check sleep mode acknowledge flag */
;;;2385       if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
00000e  680a              LDR      r2,[r1,#0]
000010  6852              LDR      r2,[r2,#4]
000012  f0020202          AND      r2,r2,#2
000016  b10a              CBZ      r2,|L11.28|
;;;2386       {
;;;2387         /* Sleep mode is active */
;;;2388         state = HAL_CAN_STATE_SLEEP_ACTIVE;
000018  2004              MOVS     r0,#4
00001a  e005              B        |L11.40|
                  |L11.28|
;;;2389       }
;;;2390       /* Check sleep mode request flag */
;;;2391       else if ((hcan->Instance->MCR & CAN_MCR_SLEEP) != 0U)
00001c  680a              LDR      r2,[r1,#0]
00001e  6812              LDR      r2,[r2,#0]
000020  f0020202          AND      r2,r2,#2
000024  b102              CBZ      r2,|L11.40|
;;;2392       {
;;;2393         /* Sleep mode request is pending */
;;;2394         state = HAL_CAN_STATE_SLEEP_PENDING;
000026  2003              MOVS     r0,#3
                  |L11.40|
;;;2395       }
;;;2396       else
;;;2397       {
;;;2398         /* Neither sleep mode request nor sleep mode acknowledge */
;;;2399       }
;;;2400     }
;;;2401   
;;;2402     /* Return CAN state */
;;;2403     return state;
;;;2404   }
000028  4770              BX       lr
;;;2405   
                          ENDP


                          AREA ||i.HAL_CAN_GetTxMailboxesFreeLevel||, CODE, READONLY, ALIGN=1

                  HAL_CAN_GetTxMailboxesFreeLevel PROC
;;;1409     */
;;;1410   uint32_t HAL_CAN_GetTxMailboxesFreeLevel(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;1411   {
;;;1412     uint32_t freelevel = 0U;
000002  2000              MOVS     r0,#0
;;;1413     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8912020          LDRB     r2,[r1,#0x20]
;;;1414   
;;;1415     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L12.16|
;;;1416         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d111              BNE      |L12.52|
                  |L12.16|
;;;1417     {
;;;1418       /* Check Tx Mailbox 0 status */
;;;1419       if ((hcan->Instance->TSR & CAN_TSR_TME0) != 0U)
000010  680b              LDR      r3,[r1,#0]
000012  689b              LDR      r3,[r3,#8]
000014  f0036380          AND      r3,r3,#0x4000000
000018  b103              CBZ      r3,|L12.28|
;;;1420       {
;;;1421         freelevel++;
00001a  1c40              ADDS     r0,r0,#1
                  |L12.28|
;;;1422       }
;;;1423   
;;;1424       /* Check Tx Mailbox 1 status */
;;;1425       if ((hcan->Instance->TSR & CAN_TSR_TME1) != 0U)
00001c  680b              LDR      r3,[r1,#0]
00001e  689b              LDR      r3,[r3,#8]
000020  f0036300          AND      r3,r3,#0x8000000
000024  b103              CBZ      r3,|L12.40|
;;;1426       {
;;;1427         freelevel++;
000026  1c40              ADDS     r0,r0,#1
                  |L12.40|
;;;1428       }
;;;1429   
;;;1430       /* Check Tx Mailbox 2 status */
;;;1431       if ((hcan->Instance->TSR & CAN_TSR_TME2) != 0U)
000028  680b              LDR      r3,[r1,#0]
00002a  689b              LDR      r3,[r3,#8]
00002c  f0035380          AND      r3,r3,#0x10000000
000030  b103              CBZ      r3,|L12.52|
;;;1432       {
;;;1433         freelevel++;
000032  1c40              ADDS     r0,r0,#1
                  |L12.52|
;;;1434       }
;;;1435     }
;;;1436   
;;;1437     /* Return Tx Mailboxes free level */
;;;1438     return freelevel;
;;;1439   }
000034  4770              BX       lr
;;;1440   
                          ENDP


                          AREA ||i.HAL_CAN_GetTxTimestamp||, CODE, READONLY, ALIGN=2

                  HAL_CAN_GetTxTimestamp PROC
;;;1484     */
;;;1485   uint32_t HAL_CAN_GetTxTimestamp(CAN_HandleTypeDef *hcan, uint32_t TxMailbox)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1486   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1487     uint32_t timestamp = 0U;
000008  f04f0800          MOV      r8,#0
;;;1488     uint32_t transmitmailbox;
;;;1489     HAL_CAN_StateTypeDef state = hcan->State;
00000c  f8957020          LDRB     r7,[r5,#0x20]
;;;1490   
;;;1491     /* Check function parameters */
;;;1492     assert_param(IS_CAN_TX_MAILBOX(TxMailbox));
000010  2c01              CMP      r4,#1
000012  d003              BEQ      |L13.28|
000014  2c02              CMP      r4,#2
000016  d001              BEQ      |L13.28|
000018  2c04              CMP      r4,#4
00001a  d100              BNE      |L13.30|
                  |L13.28|
00001c  e004              B        |L13.40|
                  |L13.30|
00001e  f24051d4          MOV      r1,#0x5d4
000022  a00b              ADR      r0,|L13.80|
000024  f7fffffe          BL       assert_failed
                  |L13.40|
;;;1493   
;;;1494     if ((state == HAL_CAN_STATE_READY) ||
000028  2f01              CMP      r7,#1
00002a  d001              BEQ      |L13.48|
;;;1495         (state == HAL_CAN_STATE_LISTENING))
00002c  2f02              CMP      r7,#2
00002e  d10b              BNE      |L13.72|
                  |L13.48|
;;;1496     {
;;;1497       /* Select the Tx mailbox */
;;;1498       transmitmailbox = POSITION_VAL(TxMailbox);
000030  fa94f0a4          RBIT     r0,r4
000034  fab0f680          CLZ      r6,r0
;;;1499   
;;;1500       /* Get timestamp */
;;;1501       timestamp = (hcan->Instance->sTxMailBox[transmitmailbox].TDTR & CAN_TDT0R_TIME) >> CAN_TDT0R_TIME_Pos;
000038  6828              LDR      r0,[r5,#0]
00003a  f50070c0          ADD      r0,r0,#0x180
00003e  eb001006          ADD      r0,r0,r6,LSL #4
000042  6840              LDR      r0,[r0,#4]
000044  ea4f4810          LSR      r8,r0,#16
                  |L13.72|
;;;1502     }
;;;1503   
;;;1504     /* Return the timestamp */
;;;1505     return timestamp;
000048  4640              MOV      r0,r8
;;;1506   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;1507   
                          ENDP

00004e  0000              DCW      0x0000
                  |L13.80|
000050  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
000054  73746d33
000058  32663478
00005c  785f6861
000060  6c5f6361
000064  6e2e6300

                          AREA ||i.HAL_CAN_IRQHandler||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IRQHandler PROC
;;;1725     */
;;;1726   void HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1727   {
000004  4604              MOV      r4,r0
;;;1728     uint32_t errorcode = HAL_CAN_ERROR_NONE;
000006  2500              MOVS     r5,#0
;;;1729     uint32_t interrupts = READ_REG(hcan->Instance->IER);
000008  6820              LDR      r0,[r4,#0]
00000a  6946              LDR      r6,[r0,#0x14]
;;;1730     uint32_t msrflags = READ_REG(hcan->Instance->MSR);
00000c  6820              LDR      r0,[r4,#0]
00000e  f8d09004          LDR      r9,[r0,#4]
;;;1731     uint32_t tsrflags = READ_REG(hcan->Instance->TSR);
000012  6820              LDR      r0,[r4,#0]
000014  6887              LDR      r7,[r0,#8]
;;;1732     uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
000016  6820              LDR      r0,[r4,#0]
000018  f8d0a00c          LDR      r10,[r0,#0xc]
;;;1733     uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
00001c  6820              LDR      r0,[r4,#0]
00001e  f8d0b010          LDR      r11,[r0,#0x10]
;;;1734     uint32_t esrflags = READ_REG(hcan->Instance->ESR);
000022  6820              LDR      r0,[r4,#0]
000024  f8d08018          LDR      r8,[r0,#0x18]
;;;1735   
;;;1736     /* Transmit Mailbox empty interrupt management *****************************/
;;;1737     if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
000028  f0060001          AND      r0,r6,#1
00002c  2800              CMP      r0,#0
00002e  d055              BEQ      |L14.220|
;;;1738     {
;;;1739       /* Transmit Mailbox 0 management *****************************************/
;;;1740       if ((tsrflags & CAN_TSR_RQCP0) != 0U)
000030  f0070001          AND      r0,r7,#1
000034  b1c0              CBZ      r0,|L14.104|
;;;1741       {
;;;1742         /* Clear the Transmission Complete flag (and TXOK0,ALST0,TERR0 bits) */
;;;1743         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
000036  2001              MOVS     r0,#1
000038  6821              LDR      r1,[r4,#0]
00003a  6088              STR      r0,[r1,#8]
;;;1744   
;;;1745         if ((tsrflags & CAN_TSR_TXOK0) != 0U)
00003c  f0070002          AND      r0,r7,#2
000040  b118              CBZ      r0,|L14.74|
;;;1746         {
;;;1747           /* Transmission Mailbox 0 complete callback */
;;;1748   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1749           /* Call registered callback*/
;;;1750           hcan->TxMailbox0CompleteCallback(hcan);
000042  4620              MOV      r0,r4
000044  6aa1              LDR      r1,[r4,#0x28]
000046  4788              BLX      r1
000048  e00e              B        |L14.104|
                  |L14.74|
;;;1751   #else
;;;1752           /* Call weak (surcharged) callback */
;;;1753           HAL_CAN_TxMailbox0CompleteCallback(hcan);
;;;1754   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1755         }
;;;1756         else
;;;1757         {
;;;1758           if ((tsrflags & CAN_TSR_ALST0) != 0U)
00004a  f0070004          AND      r0,r7,#4
00004e  b110              CBZ      r0,|L14.86|
;;;1759           {
;;;1760             /* Update error code */
;;;1761             errorcode |= HAL_CAN_ERROR_TX_ALST0;
000050  f4456500          ORR      r5,r5,#0x800
000054  e008              B        |L14.104|
                  |L14.86|
;;;1762           }
;;;1763           else if ((tsrflags & CAN_TSR_TERR0) != 0U)
000056  f0070008          AND      r0,r7,#8
00005a  b110              CBZ      r0,|L14.98|
;;;1764           {
;;;1765             /* Update error code */
;;;1766             errorcode |= HAL_CAN_ERROR_TX_TERR0;
00005c  f4455580          ORR      r5,r5,#0x1000
000060  e002              B        |L14.104|
                  |L14.98|
;;;1767           }
;;;1768           else
;;;1769           {
;;;1770             /* Transmission Mailbox 0 abort callback */
;;;1771   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1772             /* Call registered callback*/
;;;1773             hcan->TxMailbox0AbortCallback(hcan);
000062  4620              MOV      r0,r4
000064  6b61              LDR      r1,[r4,#0x34]
000066  4788              BLX      r1
                  |L14.104|
;;;1774   #else
;;;1775             /* Call weak (surcharged) callback */
;;;1776             HAL_CAN_TxMailbox0AbortCallback(hcan);
;;;1777   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1778           }
;;;1779         }
;;;1780       }
;;;1781   
;;;1782       /* Transmit Mailbox 1 management *****************************************/
;;;1783       if ((tsrflags & CAN_TSR_RQCP1) != 0U)
000068  f4077080          AND      r0,r7,#0x100
00006c  b1c8              CBZ      r0,|L14.162|
;;;1784       {
;;;1785         /* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */
;;;1786         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);
00006e  f44f7080          MOV      r0,#0x100
000072  6821              LDR      r1,[r4,#0]
000074  6088              STR      r0,[r1,#8]
;;;1787   
;;;1788         if ((tsrflags & CAN_TSR_TXOK1) != 0U)
000076  f4077000          AND      r0,r7,#0x200
00007a  b118              CBZ      r0,|L14.132|
;;;1789         {
;;;1790           /* Transmission Mailbox 1 complete callback */
;;;1791   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1792           /* Call registered callback*/
;;;1793           hcan->TxMailbox1CompleteCallback(hcan);
00007c  4620              MOV      r0,r4
00007e  6ae1              LDR      r1,[r4,#0x2c]
000080  4788              BLX      r1
000082  e00e              B        |L14.162|
                  |L14.132|
;;;1794   #else
;;;1795           /* Call weak (surcharged) callback */
;;;1796           HAL_CAN_TxMailbox1CompleteCallback(hcan);
;;;1797   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1798         }
;;;1799         else
;;;1800         {
;;;1801           if ((tsrflags & CAN_TSR_ALST1) != 0U)
000084  f4076080          AND      r0,r7,#0x400
000088  b110              CBZ      r0,|L14.144|
;;;1802           {
;;;1803             /* Update error code */
;;;1804             errorcode |= HAL_CAN_ERROR_TX_ALST1;
00008a  f4455500          ORR      r5,r5,#0x2000
00008e  e008              B        |L14.162|
                  |L14.144|
;;;1805           }
;;;1806           else if ((tsrflags & CAN_TSR_TERR1) != 0U)
000090  f4076000          AND      r0,r7,#0x800
000094  b110              CBZ      r0,|L14.156|
;;;1807           {
;;;1808             /* Update error code */
;;;1809             errorcode |= HAL_CAN_ERROR_TX_TERR1;
000096  f4454580          ORR      r5,r5,#0x4000
00009a  e002              B        |L14.162|
                  |L14.156|
;;;1810           }
;;;1811           else
;;;1812           {
;;;1813             /* Transmission Mailbox 1 abort callback */
;;;1814   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1815             /* Call registered callback*/
;;;1816             hcan->TxMailbox1AbortCallback(hcan);
00009c  4620              MOV      r0,r4
00009e  6ba1              LDR      r1,[r4,#0x38]
0000a0  4788              BLX      r1
                  |L14.162|
;;;1817   #else
;;;1818             /* Call weak (surcharged) callback */
;;;1819             HAL_CAN_TxMailbox1AbortCallback(hcan);
;;;1820   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1821           }
;;;1822         }
;;;1823       }
;;;1824   
;;;1825       /* Transmit Mailbox 2 management *****************************************/
;;;1826       if ((tsrflags & CAN_TSR_RQCP2) != 0U)
0000a2  f4073080          AND      r0,r7,#0x10000
0000a6  b1c8              CBZ      r0,|L14.220|
;;;1827       {
;;;1828         /* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */
;;;1829         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
0000a8  f44f3080          MOV      r0,#0x10000
0000ac  6821              LDR      r1,[r4,#0]
0000ae  6088              STR      r0,[r1,#8]
;;;1830   
;;;1831         if ((tsrflags & CAN_TSR_TXOK2) != 0U)
0000b0  f4073000          AND      r0,r7,#0x20000
0000b4  b118              CBZ      r0,|L14.190|
;;;1832         {
;;;1833           /* Transmission Mailbox 2 complete callback */
;;;1834   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1835           /* Call registered callback*/
;;;1836           hcan->TxMailbox2CompleteCallback(hcan);
0000b6  4620              MOV      r0,r4
0000b8  6b21              LDR      r1,[r4,#0x30]
0000ba  4788              BLX      r1
0000bc  e00e              B        |L14.220|
                  |L14.190|
;;;1837   #else
;;;1838           /* Call weak (surcharged) callback */
;;;1839           HAL_CAN_TxMailbox2CompleteCallback(hcan);
;;;1840   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1841         }
;;;1842         else
;;;1843         {
;;;1844           if ((tsrflags & CAN_TSR_ALST2) != 0U)
0000be  f4072080          AND      r0,r7,#0x40000
0000c2  b110              CBZ      r0,|L14.202|
;;;1845           {
;;;1846             /* Update error code */
;;;1847             errorcode |= HAL_CAN_ERROR_TX_ALST2;
0000c4  f4454500          ORR      r5,r5,#0x8000
0000c8  e008              B        |L14.220|
                  |L14.202|
;;;1848           }
;;;1849           else if ((tsrflags & CAN_TSR_TERR2) != 0U)
0000ca  f4072000          AND      r0,r7,#0x80000
0000ce  b110              CBZ      r0,|L14.214|
;;;1850           {
;;;1851             /* Update error code */
;;;1852             errorcode |= HAL_CAN_ERROR_TX_TERR2;
0000d0  f4453580          ORR      r5,r5,#0x10000
0000d4  e002              B        |L14.220|
                  |L14.214|
;;;1853           }
;;;1854           else
;;;1855           {
;;;1856             /* Transmission Mailbox 2 abort callback */
;;;1857   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1858             /* Call registered callback*/
;;;1859             hcan->TxMailbox2AbortCallback(hcan);
0000d6  4620              MOV      r0,r4
0000d8  6be1              LDR      r1,[r4,#0x3c]
0000da  4788              BLX      r1
                  |L14.220|
;;;1860   #else
;;;1861             /* Call weak (surcharged) callback */
;;;1862             HAL_CAN_TxMailbox2AbortCallback(hcan);
;;;1863   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1864           }
;;;1865         }
;;;1866       }
;;;1867     }
;;;1868   
;;;1869     /* Receive FIFO 0 overrun interrupt management *****************************/
;;;1870     if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)
0000dc  f0060008          AND      r0,r6,#8
0000e0  b138              CBZ      r0,|L14.242|
;;;1871     {
;;;1872       if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)
0000e2  f00a0010          AND      r0,r10,#0x10
0000e6  b120              CBZ      r0,|L14.242|
;;;1873       {
;;;1874         /* Set CAN error code to Rx Fifo 0 overrun error */
;;;1875         errorcode |= HAL_CAN_ERROR_RX_FOV0;
0000e8  f4457500          ORR      r5,r5,#0x200
;;;1876   
;;;1877         /* Clear FIFO0 Overrun Flag */
;;;1878         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
0000ec  2010              MOVS     r0,#0x10
0000ee  6821              LDR      r1,[r4,#0]
0000f0  60c8              STR      r0,[r1,#0xc]
                  |L14.242|
;;;1879       }
;;;1880     }
;;;1881   
;;;1882     /* Receive FIFO 0 full interrupt management ********************************/
;;;1883     if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)
0000f2  f0060004          AND      r0,r6,#4
0000f6  b140              CBZ      r0,|L14.266|
;;;1884     {
;;;1885       if ((rf0rflags & CAN_RF0R_FULL0) != 0U)
0000f8  f00a0008          AND      r0,r10,#8
0000fc  b128              CBZ      r0,|L14.266|
;;;1886       {
;;;1887         /* Clear FIFO 0 full Flag */
;;;1888         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
0000fe  2008              MOVS     r0,#8
000100  6821              LDR      r1,[r4,#0]
000102  60c8              STR      r0,[r1,#0xc]
;;;1889   
;;;1890         /* Receive FIFO 0 full Callback */
;;;1891   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1892         /* Call registered callback*/
;;;1893         hcan->RxFifo0FullCallback(hcan);
000104  4620              MOV      r0,r4
000106  6c61              LDR      r1,[r4,#0x44]
000108  4788              BLX      r1
                  |L14.266|
;;;1894   #else
;;;1895         /* Call weak (surcharged) callback */
;;;1896         HAL_CAN_RxFifo0FullCallback(hcan);
;;;1897   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1898       }
;;;1899     }
;;;1900   
;;;1901     /* Receive FIFO 0 message pending interrupt management *********************/
;;;1902     if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)
00010a  f0060002          AND      r0,r6,#2
00010e  b138              CBZ      r0,|L14.288|
;;;1903     {
;;;1904       /* Check if message is still pending */
;;;1905       if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)
000110  6820              LDR      r0,[r4,#0]
000112  68c0              LDR      r0,[r0,#0xc]
000114  f0000003          AND      r0,r0,#3
000118  b110              CBZ      r0,|L14.288|
;;;1906       {
;;;1907         /* Receive FIFO 0 mesage pending Callback */
;;;1908   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1909         /* Call registered callback*/
;;;1910         hcan->RxFifo0MsgPendingCallback(hcan);
00011a  4620              MOV      r0,r4
00011c  6c21              LDR      r1,[r4,#0x40]
00011e  4788              BLX      r1
                  |L14.288|
;;;1911   #else
;;;1912         /* Call weak (surcharged) callback */
;;;1913         HAL_CAN_RxFifo0MsgPendingCallback(hcan);
;;;1914   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1915       }
;;;1916     }
;;;1917   
;;;1918     /* Receive FIFO 1 overrun interrupt management *****************************/
;;;1919     if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)
000120  f0060040          AND      r0,r6,#0x40
000124  b138              CBZ      r0,|L14.310|
;;;1920     {
;;;1921       if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)
000126  f00b0010          AND      r0,r11,#0x10
00012a  b120              CBZ      r0,|L14.310|
;;;1922       {
;;;1923         /* Set CAN error code to Rx Fifo 1 overrun error */
;;;1924         errorcode |= HAL_CAN_ERROR_RX_FOV1;
00012c  f4456580          ORR      r5,r5,#0x400
;;;1925   
;;;1926         /* Clear FIFO1 Overrun Flag */
;;;1927         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
000130  2010              MOVS     r0,#0x10
000132  6821              LDR      r1,[r4,#0]
000134  6108              STR      r0,[r1,#0x10]
                  |L14.310|
;;;1928       }
;;;1929     }
;;;1930   
;;;1931     /* Receive FIFO 1 full interrupt management ********************************/
;;;1932     if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)
000136  f0060020          AND      r0,r6,#0x20
00013a  b140              CBZ      r0,|L14.334|
;;;1933     {
;;;1934       if ((rf1rflags & CAN_RF1R_FULL1) != 0U)
00013c  f00b0008          AND      r0,r11,#8
000140  b128              CBZ      r0,|L14.334|
;;;1935       {
;;;1936         /* Clear FIFO 1 full Flag */
;;;1937         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
000142  2008              MOVS     r0,#8
000144  6821              LDR      r1,[r4,#0]
000146  6108              STR      r0,[r1,#0x10]
;;;1938   
;;;1939         /* Receive FIFO 1 full Callback */
;;;1940   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1941         /* Call registered callback*/
;;;1942         hcan->RxFifo1FullCallback(hcan);
000148  4620              MOV      r0,r4
00014a  6ce1              LDR      r1,[r4,#0x4c]
00014c  4788              BLX      r1
                  |L14.334|
;;;1943   #else
;;;1944         /* Call weak (surcharged) callback */
;;;1945         HAL_CAN_RxFifo1FullCallback(hcan);
;;;1946   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1947       }
;;;1948     }
;;;1949   
;;;1950     /* Receive FIFO 1 message pending interrupt management *********************/
;;;1951     if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)
00014e  f0060010          AND      r0,r6,#0x10
000152  b138              CBZ      r0,|L14.356|
;;;1952     {
;;;1953       /* Check if message is still pending */
;;;1954       if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)
000154  6820              LDR      r0,[r4,#0]
000156  6900              LDR      r0,[r0,#0x10]
000158  f0000003          AND      r0,r0,#3
00015c  b110              CBZ      r0,|L14.356|
;;;1955       {
;;;1956         /* Receive FIFO 1 mesage pending Callback */
;;;1957   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1958         /* Call registered callback*/
;;;1959         hcan->RxFifo1MsgPendingCallback(hcan);
00015e  4620              MOV      r0,r4
000160  6ca1              LDR      r1,[r4,#0x48]
000162  4788              BLX      r1
                  |L14.356|
;;;1960   #else
;;;1961         /* Call weak (surcharged) callback */
;;;1962         HAL_CAN_RxFifo1MsgPendingCallback(hcan);
;;;1963   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1964       }
;;;1965     }
;;;1966   
;;;1967     /* Sleep interrupt management *********************************************/
;;;1968     if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)
000164  f4063000          AND      r0,r6,#0x20000
000168  b140              CBZ      r0,|L14.380|
;;;1969     {
;;;1970       if ((msrflags & CAN_MSR_SLAKI) != 0U)
00016a  f0090010          AND      r0,r9,#0x10
00016e  b128              CBZ      r0,|L14.380|
;;;1971       {
;;;1972         /* Clear Sleep interrupt Flag */
;;;1973         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
000170  2010              MOVS     r0,#0x10
000172  6821              LDR      r1,[r4,#0]
000174  6048              STR      r0,[r1,#4]
;;;1974   
;;;1975         /* Sleep Callback */
;;;1976   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1977         /* Call registered callback*/
;;;1978         hcan->SleepCallback(hcan);
000176  4620              MOV      r0,r4
000178  6d21              LDR      r1,[r4,#0x50]
00017a  4788              BLX      r1
                  |L14.380|
;;;1979   #else
;;;1980         /* Call weak (surcharged) callback */
;;;1981         HAL_CAN_SleepCallback(hcan);
;;;1982   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;1983       }
;;;1984     }
;;;1985   
;;;1986     /* WakeUp interrupt management *********************************************/
;;;1987     if ((interrupts & CAN_IT_WAKEUP) != 0U)
00017c  f4063080          AND      r0,r6,#0x10000
000180  b140              CBZ      r0,|L14.404|
;;;1988     {
;;;1989       if ((msrflags & CAN_MSR_WKUI) != 0U)
000182  f0090008          AND      r0,r9,#8
000186  b128              CBZ      r0,|L14.404|
;;;1990       {
;;;1991         /* Clear WakeUp Flag */
;;;1992         __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
000188  2008              MOVS     r0,#8
00018a  6821              LDR      r1,[r4,#0]
00018c  6048              STR      r0,[r1,#4]
;;;1993   
;;;1994         /* WakeUp Callback */
;;;1995   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;1996         /* Call registered callback*/
;;;1997         hcan->WakeUpFromRxMsgCallback(hcan);
00018e  4620              MOV      r0,r4
000190  6d61              LDR      r1,[r4,#0x54]
000192  4788              BLX      r1
                  |L14.404|
;;;1998   #else
;;;1999         /* Call weak (surcharged) callback */
;;;2000         HAL_CAN_WakeUpFromRxMsgCallback(hcan);
;;;2001   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;2002       }
;;;2003     }
;;;2004   
;;;2005     /* Error interrupts management *********************************************/
;;;2006     if ((interrupts & CAN_IT_ERROR) != 0U)
000194  f4064000          AND      r0,r6,#0x8000
000198  b388              CBZ      r0,|L14.510|
;;;2007     {
;;;2008       if ((msrflags & CAN_MSR_ERRI) != 0U)
00019a  f0090004          AND      r0,r9,#4
00019e  b378              CBZ      r0,|L14.512|
;;;2009       {
;;;2010         /* Check Error Warning Flag */
;;;2011         if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
0001a0  f4067080          AND      r0,r6,#0x100
0001a4  b120              CBZ      r0,|L14.432|
;;;2012             ((esrflags & CAN_ESR_EWGF) != 0U))
0001a6  f0080001          AND      r0,r8,#1
0001aa  b108              CBZ      r0,|L14.432|
;;;2013         {
;;;2014           /* Set CAN error code to Error Warning */
;;;2015           errorcode |= HAL_CAN_ERROR_EWG;
0001ac  f0450501          ORR      r5,r5,#1
                  |L14.432|
;;;2016   
;;;2017           /* No need for clear of Error Warning Flag as read-only */
;;;2018         }
;;;2019   
;;;2020         /* Check Error Passive Flag */
;;;2021         if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
0001b0  f4067000          AND      r0,r6,#0x200
0001b4  b120              CBZ      r0,|L14.448|
;;;2022             ((esrflags & CAN_ESR_EPVF) != 0U))
0001b6  f0080002          AND      r0,r8,#2
0001ba  b108              CBZ      r0,|L14.448|
;;;2023         {
;;;2024           /* Set CAN error code to Error Passive */
;;;2025           errorcode |= HAL_CAN_ERROR_EPV;
0001bc  f0450502          ORR      r5,r5,#2
                  |L14.448|
;;;2026   
;;;2027           /* No need for clear of Error Passive Flag as read-only */
;;;2028         }
;;;2029   
;;;2030         /* Check Bus-off Flag */
;;;2031         if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
0001c0  f4066080          AND      r0,r6,#0x400
0001c4  b120              CBZ      r0,|L14.464|
;;;2032             ((esrflags & CAN_ESR_BOFF) != 0U))
0001c6  f0080004          AND      r0,r8,#4
0001ca  b108              CBZ      r0,|L14.464|
;;;2033         {
;;;2034           /* Set CAN error code to Bus-Off */
;;;2035           errorcode |= HAL_CAN_ERROR_BOF;
0001cc  f0450504          ORR      r5,r5,#4
                  |L14.464|
;;;2036   
;;;2037           /* No need for clear of Error Bus-Off as read-only */
;;;2038         }
;;;2039   
;;;2040         /* Check Last Error Code Flag */
;;;2041         if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
0001d0  f4066000          AND      r0,r6,#0x800
0001d4  b1a0              CBZ      r0,|L14.512|
;;;2042             ((esrflags & CAN_ESR_LEC) != 0U))
0001d6  f0080070          AND      r0,r8,#0x70
0001da  b188              CBZ      r0,|L14.512|
;;;2043         {
;;;2044           switch (esrflags & CAN_ESR_LEC)
0001dc  f0080070          AND      r0,r8,#0x70
0001e0  2840              CMP      r0,#0x40
0001e2  d017              BEQ      |L14.532|
0001e4  dc06              BGT      |L14.500|
0001e6  2810              CMP      r0,#0x10
0001e8  d00b              BEQ      |L14.514|
0001ea  2820              CMP      r0,#0x20
0001ec  d00c              BEQ      |L14.520|
0001ee  2830              CMP      r0,#0x30
0001f0  d119              BNE      |L14.550|
0001f2  e00c              B        |L14.526|
                  |L14.500|
0001f4  2850              CMP      r0,#0x50
0001f6  d010              BEQ      |L14.538|
0001f8  2860              CMP      r0,#0x60
0001fa  d114              BNE      |L14.550|
0001fc  e010              B        |L14.544|
                  |L14.510|
0001fe  e01d              B        |L14.572|
                  |L14.512|
000200  e019              B        |L14.566|
                  |L14.514|
;;;2045           {
;;;2046             case (CAN_ESR_LEC_0):
;;;2047               /* Set CAN error code to Stuff error */
;;;2048               errorcode |= HAL_CAN_ERROR_STF;
000202  f0450508          ORR      r5,r5,#8
;;;2049               break;
000206  e00f              B        |L14.552|
                  |L14.520|
;;;2050             case (CAN_ESR_LEC_1):
;;;2051               /* Set CAN error code to Form error */
;;;2052               errorcode |= HAL_CAN_ERROR_FOR;
000208  f0450510          ORR      r5,r5,#0x10
;;;2053               break;
00020c  e00c              B        |L14.552|
                  |L14.526|
;;;2054             case (CAN_ESR_LEC_1 | CAN_ESR_LEC_0):
;;;2055               /* Set CAN error code to Acknowledgement error */
;;;2056               errorcode |= HAL_CAN_ERROR_ACK;
00020e  f0450520          ORR      r5,r5,#0x20
;;;2057               break;
000212  e009              B        |L14.552|
                  |L14.532|
;;;2058             case (CAN_ESR_LEC_2):
;;;2059               /* Set CAN error code to Bit recessive error */
;;;2060               errorcode |= HAL_CAN_ERROR_BR;
000214  f0450540          ORR      r5,r5,#0x40
;;;2061               break;
000218  e006              B        |L14.552|
                  |L14.538|
;;;2062             case (CAN_ESR_LEC_2 | CAN_ESR_LEC_0):
;;;2063               /* Set CAN error code to Bit Dominant error */
;;;2064               errorcode |= HAL_CAN_ERROR_BD;
00021a  f0450580          ORR      r5,r5,#0x80
;;;2065               break;
00021e  e003              B        |L14.552|
                  |L14.544|
;;;2066             case (CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
;;;2067               /* Set CAN error code to CRC error */
;;;2068               errorcode |= HAL_CAN_ERROR_CRC;
000220  f4457580          ORR      r5,r5,#0x100
;;;2069               break;
000224  e000              B        |L14.552|
                  |L14.550|
;;;2070             default:
;;;2071               break;
000226  bf00              NOP      
                  |L14.552|
000228  bf00              NOP                            ;2049
;;;2072           }
;;;2073   
;;;2074           /* Clear Last error code Flag */
;;;2075           CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
00022a  6820              LDR      r0,[r4,#0]
00022c  6980              LDR      r0,[r0,#0x18]
00022e  f0200070          BIC      r0,r0,#0x70
000232  6821              LDR      r1,[r4,#0]
000234  6188              STR      r0,[r1,#0x18]
                  |L14.566|
;;;2076         }
;;;2077       }
;;;2078   
;;;2079       /* Clear ERRI Flag */
;;;2080       __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
000236  2004              MOVS     r0,#4
000238  6821              LDR      r1,[r4,#0]
00023a  6048              STR      r0,[r1,#4]
                  |L14.572|
;;;2081     }
;;;2082   
;;;2083     /* Call the Error call Back in case of Errors */
;;;2084     if (errorcode != HAL_CAN_ERROR_NONE)
00023c  b12d              CBZ      r5,|L14.586|
;;;2085     {
;;;2086       /* Update error code in handle */
;;;2087       hcan->ErrorCode |= errorcode;
00023e  6a60              LDR      r0,[r4,#0x24]
000240  4328              ORRS     r0,r0,r5
000242  6260              STR      r0,[r4,#0x24]
;;;2088   
;;;2089       /* Call Error callback function */
;;;2090   #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;2091       /* Call registered callback*/
;;;2092       hcan->ErrorCallback(hcan);
000244  4620              MOV      r0,r4
000246  6da1              LDR      r1,[r4,#0x58]
000248  4788              BLX      r1
                  |L14.586|
;;;2093   #else
;;;2094       /* Call weak (surcharged) callback */
;;;2095       HAL_CAN_ErrorCallback(hcan);
;;;2096   #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
;;;2097     }
;;;2098   }
00024a  e8bd9ff0          POP      {r4-r12,pc}
;;;2099   
                          ENDP


                          AREA ||i.HAL_CAN_Init||, CODE, READONLY, ALIGN=2

                  HAL_CAN_Init PROC
;;;276      */
;;;277    HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;278    {
000002  4604              MOV      r4,r0
;;;279      uint32_t tickstart;
;;;280    
;;;281      /* Check CAN handle */
;;;282      if (hcan == NULL)
000004  b90c              CBNZ     r4,|L15.10|
;;;283      {
;;;284        return HAL_ERROR;
000006  2001              MOVS     r0,#1
                  |L15.8|
;;;285      }
;;;286    
;;;287      /* Check the parameters */
;;;288    // LBR  assert_param(IS_CAN_ALL_INSTANCE(hcan->Instance));
;;;289      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TimeTriggeredMode));
;;;290      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoBusOff));
;;;291      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoWakeUp));
;;;292      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.AutoRetransmission));
;;;293      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.ReceiveFifoLocked));
;;;294      assert_param(IS_FUNCTIONAL_STATE(hcan->Init.TransmitFifoPriority));
;;;295      assert_param(IS_CAN_MODE(hcan->Init.Mode));
;;;296      assert_param(IS_CAN_SJW(hcan->Init.SyncJumpWidth));
;;;297      assert_param(IS_CAN_BS1(hcan->Init.TimeSeg1));
;;;298      assert_param(IS_CAN_BS2(hcan->Init.TimeSeg2));
;;;299      assert_param(IS_CAN_PRESCALER(hcan->Init.Prescaler));
;;;300    
;;;301    #if USE_HAL_CAN_REGISTER_CALLBACKS == 1
;;;302      if (hcan->State == HAL_CAN_STATE_RESET)
;;;303      {
;;;304        /* Reset callbacks to legacy functions */
;;;305        hcan->RxFifo0MsgPendingCallback  =  HAL_CAN_RxFifo0MsgPendingCallback;  /* Legacy weak RxFifo0MsgPendingCallback  */
;;;306        hcan->RxFifo0FullCallback        =  HAL_CAN_RxFifo0FullCallback;        /* Legacy weak RxFifo0FullCallback        */
;;;307        hcan->RxFifo1MsgPendingCallback  =  HAL_CAN_RxFifo1MsgPendingCallback;  /* Legacy weak RxFifo1MsgPendingCallback  */
;;;308        hcan->RxFifo1FullCallback        =  HAL_CAN_RxFifo1FullCallback;        /* Legacy weak RxFifo1FullCallback        */
;;;309        hcan->TxMailbox0CompleteCallback =  HAL_CAN_TxMailbox0CompleteCallback; /* Legacy weak TxMailbox0CompleteCallback */
;;;310        hcan->TxMailbox1CompleteCallback =  HAL_CAN_TxMailbox1CompleteCallback; /* Legacy weak TxMailbox1CompleteCallback */
;;;311        hcan->TxMailbox2CompleteCallback =  HAL_CAN_TxMailbox2CompleteCallback; /* Legacy weak TxMailbox2CompleteCallback */
;;;312        hcan->TxMailbox0AbortCallback    =  HAL_CAN_TxMailbox0AbortCallback;    /* Legacy weak TxMailbox0AbortCallback    */
;;;313        hcan->TxMailbox1AbortCallback    =  HAL_CAN_TxMailbox1AbortCallback;    /* Legacy weak TxMailbox1AbortCallback    */
;;;314        hcan->TxMailbox2AbortCallback    =  HAL_CAN_TxMailbox2AbortCallback;    /* Legacy weak TxMailbox2AbortCallback    */
;;;315        hcan->SleepCallback              =  HAL_CAN_SleepCallback;              /* Legacy weak SleepCallback              */
;;;316        hcan->WakeUpFromRxMsgCallback    =  HAL_CAN_WakeUpFromRxMsgCallback;    /* Legacy weak WakeUpFromRxMsgCallback    */
;;;317        hcan->ErrorCallback              =  HAL_CAN_ErrorCallback;              /* Legacy weak ErrorCallback              */
;;;318    
;;;319        if (hcan->MspInitCallback == NULL)
;;;320        {
;;;321          hcan->MspInitCallback = HAL_CAN_MspInit; /* Legacy weak MspInit */
;;;322        }
;;;323    
;;;324        /* Init the low level hardware: CLOCK, NVIC */
;;;325        hcan->MspInitCallback(hcan);
;;;326      }
;;;327    
;;;328    #else
;;;329      if (hcan->State == HAL_CAN_STATE_RESET)
;;;330      {
;;;331        /* Init the low level hardware: CLOCK, NVIC */
;;;332        HAL_CAN_MspInit(hcan);
;;;333      }
;;;334    #endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */
;;;335    
;;;336      /* Exit from sleep mode */
;;;337      CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;338    
;;;339      /* Get tick */
;;;340      tickstart = HAL_GetTick();
;;;341    
;;;342      /* Check Sleep mode leave acknowledge */
;;;343      while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
;;;344      {
;;;345        if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;346        {
;;;347          /* Update error code */
;;;348          hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;349    
;;;350          /* Change CAN state */
;;;351          hcan->State = HAL_CAN_STATE_ERROR;
;;;352    
;;;353          return HAL_ERROR;
;;;354        }
;;;355      }
;;;356    
;;;357      /* Request initialisation */
;;;358      SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
;;;359    
;;;360      /* Get tick */
;;;361      tickstart = HAL_GetTick();
;;;362    
;;;363      /* Wait initialisation acknowledge */
;;;364      while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
;;;365      {
;;;366        if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
;;;367        {
;;;368          /* Update error code */
;;;369          hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
;;;370    
;;;371          /* Change CAN state */
;;;372          hcan->State = HAL_CAN_STATE_ERROR;
;;;373    
;;;374          return HAL_ERROR;
;;;375        }
;;;376      }
;;;377    
;;;378      /* Set the time triggered communication mode */
;;;379      if (hcan->Init.TimeTriggeredMode == ENABLE)
;;;380      {
;;;381        SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
;;;382      }
;;;383      else
;;;384      {
;;;385        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
;;;386      }
;;;387    
;;;388      /* Set the automatic bus-off management */
;;;389      if (hcan->Init.AutoBusOff == ENABLE)
;;;390      {
;;;391        SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
;;;392      }
;;;393      else
;;;394      {
;;;395        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
;;;396      }
;;;397    
;;;398      /* Set the automatic wake-up mode */
;;;399      if (hcan->Init.AutoWakeUp == ENABLE)
;;;400      {
;;;401        SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
;;;402      }
;;;403      else
;;;404      {
;;;405        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
;;;406      }
;;;407    
;;;408      /* Set the automatic retransmission */
;;;409      if (hcan->Init.AutoRetransmission == ENABLE)
;;;410      {
;;;411        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
;;;412      }
;;;413      else
;;;414      {
;;;415        SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
;;;416      }
;;;417    
;;;418      /* Set the receive FIFO locked mode */
;;;419      if (hcan->Init.ReceiveFifoLocked == ENABLE)
;;;420      {
;;;421        SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
;;;422      }
;;;423      else
;;;424      {
;;;425        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
;;;426      }
;;;427    
;;;428      /* Set the transmit FIFO priority */
;;;429      if (hcan->Init.TransmitFifoPriority == ENABLE)
;;;430      {
;;;431        SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
;;;432      }
;;;433      else
;;;434      {
;;;435        CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
;;;436      }
;;;437    
;;;438      /* Set the bit timing register */
;;;439      WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
;;;440                                                hcan->Init.SyncJumpWidth  |
;;;441                                                hcan->Init.TimeSeg1       |
;;;442                                                hcan->Init.TimeSeg2       |
;;;443                                                (hcan->Init.Prescaler - 1U)));
;;;444    
;;;445      /* Initialize the error code */
;;;446      hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;447    
;;;448      /* Initialize the CAN state */
;;;449      hcan->State = HAL_CAN_STATE_READY;
;;;450    
;;;451      /* Return function status */
;;;452      return HAL_OK;
;;;453    }
000008  bd70              POP      {r4-r6,pc}
                  |L15.10|
00000a  7e20              LDRB     r0,[r4,#0x18]         ;289
00000c  b110              CBZ      r0,|L15.20|
00000e  7e20              LDRB     r0,[r4,#0x18]         ;289
000010  2801              CMP      r0,#1                 ;289
000012  d100              BNE      |L15.22|
                  |L15.20|
000014  e004              B        |L15.32|
                  |L15.22|
000016  f2401121          MOV      r1,#0x121             ;289
00001a  a0d4              ADR      r0,|L15.876|
00001c  f7fffffe          BL       assert_failed
                  |L15.32|
000020  7e60              LDRB     r0,[r4,#0x19]         ;290
000022  b110              CBZ      r0,|L15.42|
000024  7e60              LDRB     r0,[r4,#0x19]         ;290
000026  2801              CMP      r0,#1                 ;290
000028  d100              BNE      |L15.44|
                  |L15.42|
00002a  e004              B        |L15.54|
                  |L15.44|
00002c  f44f7191          MOV      r1,#0x122             ;290
000030  a0ce              ADR      r0,|L15.876|
000032  f7fffffe          BL       assert_failed
                  |L15.54|
000036  7ea0              LDRB     r0,[r4,#0x1a]         ;291
000038  b110              CBZ      r0,|L15.64|
00003a  7ea0              LDRB     r0,[r4,#0x1a]         ;291
00003c  2801              CMP      r0,#1                 ;291
00003e  d100              BNE      |L15.66|
                  |L15.64|
000040  e004              B        |L15.76|
                  |L15.66|
000042  f2401123          MOV      r1,#0x123             ;291
000046  a0c9              ADR      r0,|L15.876|
000048  f7fffffe          BL       assert_failed
                  |L15.76|
00004c  7ee0              LDRB     r0,[r4,#0x1b]         ;292
00004e  b110              CBZ      r0,|L15.86|
000050  7ee0              LDRB     r0,[r4,#0x1b]         ;292
000052  2801              CMP      r0,#1                 ;292
000054  d100              BNE      |L15.88|
                  |L15.86|
000056  e004              B        |L15.98|
                  |L15.88|
000058  f44f7192          MOV      r1,#0x124             ;292
00005c  a0c3              ADR      r0,|L15.876|
00005e  f7fffffe          BL       assert_failed
                  |L15.98|
000062  7f20              LDRB     r0,[r4,#0x1c]         ;293
000064  b110              CBZ      r0,|L15.108|
000066  7f20              LDRB     r0,[r4,#0x1c]         ;293
000068  2801              CMP      r0,#1                 ;293
00006a  d100              BNE      |L15.110|
                  |L15.108|
00006c  e004              B        |L15.120|
                  |L15.110|
00006e  f2401125          MOV      r1,#0x125             ;293
000072  a0be              ADR      r0,|L15.876|
000074  f7fffffe          BL       assert_failed
                  |L15.120|
000078  7f60              LDRB     r0,[r4,#0x1d]         ;294
00007a  b110              CBZ      r0,|L15.130|
00007c  7f60              LDRB     r0,[r4,#0x1d]         ;294
00007e  2801              CMP      r0,#1                 ;294
000080  d100              BNE      |L15.132|
                  |L15.130|
000082  e004              B        |L15.142|
                  |L15.132|
000084  f44f7193          MOV      r1,#0x126             ;294
000088  a0b8              ADR      r0,|L15.876|
00008a  f7fffffe          BL       assert_failed
                  |L15.142|
00008e  68a0              LDR      r0,[r4,#8]            ;295
000090  b158              CBZ      r0,|L15.170|
000092  68a0              LDR      r0,[r4,#8]            ;295
000094  f1b04f80          CMP      r0,#0x40000000        ;295
000098  d007              BEQ      |L15.170|
00009a  68a0              LDR      r0,[r4,#8]            ;295
00009c  f1b04f00          CMP      r0,#0x80000000        ;295
0000a0  d003              BEQ      |L15.170|
0000a2  68a0              LDR      r0,[r4,#8]            ;295
0000a4  f1b04f40          CMP      r0,#0xc0000000        ;295
0000a8  d100              BNE      |L15.172|
                  |L15.170|
0000aa  e004              B        |L15.182|
                  |L15.172|
0000ac  f2401127          MOV      r1,#0x127             ;295
0000b0  a0ae              ADR      r0,|L15.876|
0000b2  f7fffffe          BL       assert_failed
                  |L15.182|
0000b6  68e0              LDR      r0,[r4,#0xc]          ;296
0000b8  b158              CBZ      r0,|L15.210|
0000ba  68e0              LDR      r0,[r4,#0xc]          ;296
0000bc  f1b07f80          CMP      r0,#0x1000000         ;296
0000c0  d007              BEQ      |L15.210|
0000c2  68e0              LDR      r0,[r4,#0xc]          ;296
0000c4  f1b07f00          CMP      r0,#0x2000000         ;296
0000c8  d003              BEQ      |L15.210|
0000ca  68e0              LDR      r0,[r4,#0xc]          ;296
0000cc  f1b07f40          CMP      r0,#0x3000000         ;296
0000d0  d100              BNE      |L15.212|
                  |L15.210|
0000d2  e004              B        |L15.222|
                  |L15.212|
0000d4  f44f7194          MOV      r1,#0x128             ;296
0000d8  a0a4              ADR      r0,|L15.876|
0000da  f7fffffe          BL       assert_failed
                  |L15.222|
0000de  6920              LDR      r0,[r4,#0x10]         ;297
0000e0  b3d8              CBZ      r0,|L15.346|
0000e2  6920              LDR      r0,[r4,#0x10]         ;297
0000e4  f5b03f80          CMP      r0,#0x10000           ;297
0000e8  d037              BEQ      |L15.346|
0000ea  6920              LDR      r0,[r4,#0x10]         ;297
0000ec  f5b03f00          CMP      r0,#0x20000           ;297
0000f0  d033              BEQ      |L15.346|
0000f2  6920              LDR      r0,[r4,#0x10]         ;297
0000f4  f5b03f40          CMP      r0,#0x30000           ;297
0000f8  d02f              BEQ      |L15.346|
0000fa  6920              LDR      r0,[r4,#0x10]         ;297
0000fc  f5b02f80          CMP      r0,#0x40000           ;297
000100  d02b              BEQ      |L15.346|
000102  6920              LDR      r0,[r4,#0x10]         ;297
000104  f5b02fa0          CMP      r0,#0x50000           ;297
000108  d027              BEQ      |L15.346|
00010a  6920              LDR      r0,[r4,#0x10]         ;297
00010c  f5b02fc0          CMP      r0,#0x60000           ;297
000110  d023              BEQ      |L15.346|
000112  6920              LDR      r0,[r4,#0x10]         ;297
000114  f5b02fe0          CMP      r0,#0x70000           ;297
000118  d01f              BEQ      |L15.346|
00011a  6920              LDR      r0,[r4,#0x10]         ;297
00011c  f5b02f00          CMP      r0,#0x80000           ;297
000120  d01b              BEQ      |L15.346|
000122  6920              LDR      r0,[r4,#0x10]         ;297
000124  f5b02f10          CMP      r0,#0x90000           ;297
000128  d017              BEQ      |L15.346|
00012a  6920              LDR      r0,[r4,#0x10]         ;297
00012c  f5b02f20          CMP      r0,#0xa0000           ;297
000130  d013              BEQ      |L15.346|
000132  6920              LDR      r0,[r4,#0x10]         ;297
000134  f5b02f30          CMP      r0,#0xb0000           ;297
000138  d00f              BEQ      |L15.346|
00013a  6920              LDR      r0,[r4,#0x10]         ;297
00013c  f5b02f40          CMP      r0,#0xc0000           ;297
000140  d00b              BEQ      |L15.346|
000142  6920              LDR      r0,[r4,#0x10]         ;297
000144  f5b02f50          CMP      r0,#0xd0000           ;297
000148  d007              BEQ      |L15.346|
00014a  6920              LDR      r0,[r4,#0x10]         ;297
00014c  f5b02f60          CMP      r0,#0xe0000           ;297
000150  d003              BEQ      |L15.346|
000152  6920              LDR      r0,[r4,#0x10]         ;297
000154  f5b02f70          CMP      r0,#0xf0000           ;297
000158  d100              BNE      |L15.348|
                  |L15.346|
00015a  e004              B        |L15.358|
                  |L15.348|
00015c  f2401129          MOV      r1,#0x129             ;297
000160  a082              ADR      r0,|L15.876|
000162  f7fffffe          BL       assert_failed
                  |L15.358|
000166  6960              LDR      r0,[r4,#0x14]         ;298
000168  b1d8              CBZ      r0,|L15.418|
00016a  6960              LDR      r0,[r4,#0x14]         ;298
00016c  f5b01f80          CMP      r0,#0x100000          ;298
000170  d017              BEQ      |L15.418|
000172  6960              LDR      r0,[r4,#0x14]         ;298
000174  f5b01f00          CMP      r0,#0x200000          ;298
000178  d013              BEQ      |L15.418|
00017a  6960              LDR      r0,[r4,#0x14]         ;298
00017c  f5b01f40          CMP      r0,#0x300000          ;298
000180  d00f              BEQ      |L15.418|
000182  6960              LDR      r0,[r4,#0x14]         ;298
000184  f5b00f80          CMP      r0,#0x400000          ;298
000188  d00b              BEQ      |L15.418|
00018a  6960              LDR      r0,[r4,#0x14]         ;298
00018c  f5b00fa0          CMP      r0,#0x500000          ;298
000190  d007              BEQ      |L15.418|
000192  6960              LDR      r0,[r4,#0x14]         ;298
000194  f5b00fc0          CMP      r0,#0x600000          ;298
000198  d003              BEQ      |L15.418|
00019a  6960              LDR      r0,[r4,#0x14]         ;298
00019c  f5b00fe0          CMP      r0,#0x700000          ;298
0001a0  d100              BNE      |L15.420|
                  |L15.418|
0001a2  e004              B        |L15.430|
                  |L15.420|
0001a4  f44f7195          MOV      r1,#0x12a             ;298
0001a8  a070              ADR      r0,|L15.876|
0001aa  f7fffffe          BL       assert_failed
                  |L15.430|
0001ae  6860              LDR      r0,[r4,#4]            ;299
0001b0  b120              CBZ      r0,|L15.444|
0001b2  6860              LDR      r0,[r4,#4]            ;299
0001b4  f5b06f80          CMP      r0,#0x400             ;299
0001b8  d800              BHI      |L15.444|
0001ba  e004              B        |L15.454|
                  |L15.444|
0001bc  f240112b          MOV      r1,#0x12b             ;299
0001c0  a06a              ADR      r0,|L15.876|
0001c2  f7fffffe          BL       assert_failed
                  |L15.454|
0001c6  f8940020          LDRB     r0,[r4,#0x20]         ;302
0001ca  bb00              CBNZ     r0,|L15.526|
0001cc  486d              LDR      r0,|L15.900|
0001ce  6420              STR      r0,[r4,#0x40]         ;305
0001d0  486d              LDR      r0,|L15.904|
0001d2  6460              STR      r0,[r4,#0x44]         ;306
0001d4  486d              LDR      r0,|L15.908|
0001d6  64a0              STR      r0,[r4,#0x48]         ;307
0001d8  486d              LDR      r0,|L15.912|
0001da  64e0              STR      r0,[r4,#0x4c]         ;308
0001dc  486d              LDR      r0,|L15.916|
0001de  62a0              STR      r0,[r4,#0x28]         ;309
0001e0  486d              LDR      r0,|L15.920|
0001e2  62e0              STR      r0,[r4,#0x2c]         ;310
0001e4  486d              LDR      r0,|L15.924|
0001e6  6320              STR      r0,[r4,#0x30]         ;311
0001e8  486d              LDR      r0,|L15.928|
0001ea  6360              STR      r0,[r4,#0x34]         ;312
0001ec  486d              LDR      r0,|L15.932|
0001ee  63a0              STR      r0,[r4,#0x38]         ;313
0001f0  486d              LDR      r0,|L15.936|
0001f2  63e0              STR      r0,[r4,#0x3c]         ;314
0001f4  486d              LDR      r0,|L15.940|
0001f6  6520              STR      r0,[r4,#0x50]         ;315
0001f8  486d              LDR      r0,|L15.944|
0001fa  6560              STR      r0,[r4,#0x54]         ;316
0001fc  486d              LDR      r0,|L15.948|
0001fe  65a0              STR      r0,[r4,#0x58]         ;317
000200  6de0              LDR      r0,[r4,#0x5c]         ;319
000202  b908              CBNZ     r0,|L15.520|
000204  486c              LDR      r0,|L15.952|
000206  65e0              STR      r0,[r4,#0x5c]         ;321
                  |L15.520|
000208  4620              MOV      r0,r4                 ;325
00020a  6de1              LDR      r1,[r4,#0x5c]         ;325
00020c  4788              BLX      r1                    ;325
                  |L15.526|
00020e  6820              LDR      r0,[r4,#0]            ;337
000210  6800              LDR      r0,[r0,#0]            ;337
000212  f0200002          BIC      r0,r0,#2              ;337
000216  6821              LDR      r1,[r4,#0]            ;337
000218  6008              STR      r0,[r1,#0]            ;337
00021a  f7fffffe          BL       SysTick_GetTick
00021e  4605              MOV      r5,r0                 ;340
000220  e00d              B        |L15.574|
                  |L15.546|
000222  f7fffffe          BL       SysTick_GetTick
000226  1b40              SUBS     r0,r0,r5              ;345
000228  280a              CMP      r0,#0xa               ;345
00022a  d908              BLS      |L15.574|
00022c  6a60              LDR      r0,[r4,#0x24]         ;348
00022e  f4403000          ORR      r0,r0,#0x20000        ;348
000232  6260              STR      r0,[r4,#0x24]         ;348
000234  2005              MOVS     r0,#5                 ;351
000236  f8840020          STRB     r0,[r4,#0x20]         ;351
00023a  2001              MOVS     r0,#1                 ;353
00023c  e6e4              B        |L15.8|
                  |L15.574|
00023e  6820              LDR      r0,[r4,#0]            ;343
000240  6840              LDR      r0,[r0,#4]            ;343
000242  f0000002          AND      r0,r0,#2              ;343
000246  2800              CMP      r0,#0                 ;343
000248  d1eb              BNE      |L15.546|
00024a  6820              LDR      r0,[r4,#0]            ;358
00024c  6800              LDR      r0,[r0,#0]            ;358
00024e  f0400001          ORR      r0,r0,#1              ;358
000252  6821              LDR      r1,[r4,#0]            ;358
000254  6008              STR      r0,[r1,#0]            ;358
000256  f7fffffe          BL       SysTick_GetTick
00025a  4605              MOV      r5,r0                 ;361
00025c  e00d              B        |L15.634|
                  |L15.606|
00025e  f7fffffe          BL       SysTick_GetTick
000262  1b40              SUBS     r0,r0,r5              ;366
000264  280a              CMP      r0,#0xa               ;366
000266  d908              BLS      |L15.634|
000268  6a60              LDR      r0,[r4,#0x24]         ;369
00026a  f4403000          ORR      r0,r0,#0x20000        ;369
00026e  6260              STR      r0,[r4,#0x24]         ;369
000270  2005              MOVS     r0,#5                 ;372
000272  f8840020          STRB     r0,[r4,#0x20]         ;372
000276  2001              MOVS     r0,#1                 ;374
000278  e6c6              B        |L15.8|
                  |L15.634|
00027a  6820              LDR      r0,[r4,#0]            ;364
00027c  6840              LDR      r0,[r0,#4]            ;364
00027e  f0000001          AND      r0,r0,#1              ;364
000282  2800              CMP      r0,#0                 ;364
000284  d0eb              BEQ      |L15.606|
000286  7e20              LDRB     r0,[r4,#0x18]         ;379
000288  2801              CMP      r0,#1                 ;379
00028a  d106              BNE      |L15.666|
00028c  6820              LDR      r0,[r4,#0]            ;381
00028e  6800              LDR      r0,[r0,#0]            ;381
000290  f0400080          ORR      r0,r0,#0x80           ;381
000294  6821              LDR      r1,[r4,#0]            ;381
000296  6008              STR      r0,[r1,#0]            ;381
000298  e005              B        |L15.678|
                  |L15.666|
00029a  6820              LDR      r0,[r4,#0]            ;385
00029c  6800              LDR      r0,[r0,#0]            ;385
00029e  f0200080          BIC      r0,r0,#0x80           ;385
0002a2  6821              LDR      r1,[r4,#0]            ;385
0002a4  6008              STR      r0,[r1,#0]            ;385
                  |L15.678|
0002a6  7e60              LDRB     r0,[r4,#0x19]         ;389
0002a8  2801              CMP      r0,#1                 ;389
0002aa  d106              BNE      |L15.698|
0002ac  6820              LDR      r0,[r4,#0]            ;391
0002ae  6800              LDR      r0,[r0,#0]            ;391
0002b0  f0400040          ORR      r0,r0,#0x40           ;391
0002b4  6821              LDR      r1,[r4,#0]            ;391
0002b6  6008              STR      r0,[r1,#0]            ;391
0002b8  e005              B        |L15.710|
                  |L15.698|
0002ba  6820              LDR      r0,[r4,#0]            ;395
0002bc  6800              LDR      r0,[r0,#0]            ;395
0002be  f0200040          BIC      r0,r0,#0x40           ;395
0002c2  6821              LDR      r1,[r4,#0]            ;395
0002c4  6008              STR      r0,[r1,#0]            ;395
                  |L15.710|
0002c6  7ea0              LDRB     r0,[r4,#0x1a]         ;399
0002c8  2801              CMP      r0,#1                 ;399
0002ca  d106              BNE      |L15.730|
0002cc  6820              LDR      r0,[r4,#0]            ;401
0002ce  6800              LDR      r0,[r0,#0]            ;401
0002d0  f0400020          ORR      r0,r0,#0x20           ;401
0002d4  6821              LDR      r1,[r4,#0]            ;401
0002d6  6008              STR      r0,[r1,#0]            ;401
0002d8  e005              B        |L15.742|
                  |L15.730|
0002da  6820              LDR      r0,[r4,#0]            ;405
0002dc  6800              LDR      r0,[r0,#0]            ;405
0002de  f0200020          BIC      r0,r0,#0x20           ;405
0002e2  6821              LDR      r1,[r4,#0]            ;405
0002e4  6008              STR      r0,[r1,#0]            ;405
                  |L15.742|
0002e6  7ee0              LDRB     r0,[r4,#0x1b]         ;409
0002e8  2801              CMP      r0,#1                 ;409
0002ea  d106              BNE      |L15.762|
0002ec  6820              LDR      r0,[r4,#0]            ;411
0002ee  6800              LDR      r0,[r0,#0]            ;411
0002f0  f0200010          BIC      r0,r0,#0x10           ;411
0002f4  6821              LDR      r1,[r4,#0]            ;411
0002f6  6008              STR      r0,[r1,#0]            ;411
0002f8  e005              B        |L15.774|
                  |L15.762|
0002fa  6820              LDR      r0,[r4,#0]            ;415
0002fc  6800              LDR      r0,[r0,#0]            ;415
0002fe  f0400010          ORR      r0,r0,#0x10           ;415
000302  6821              LDR      r1,[r4,#0]            ;415
000304  6008              STR      r0,[r1,#0]            ;415
                  |L15.774|
000306  7f20              LDRB     r0,[r4,#0x1c]         ;419
000308  2801              CMP      r0,#1                 ;419
00030a  d106              BNE      |L15.794|
00030c  6820              LDR      r0,[r4,#0]            ;421
00030e  6800              LDR      r0,[r0,#0]            ;421
000310  f0400008          ORR      r0,r0,#8              ;421
000314  6821              LDR      r1,[r4,#0]            ;421
000316  6008              STR      r0,[r1,#0]            ;421
000318  e005              B        |L15.806|
                  |L15.794|
00031a  6820              LDR      r0,[r4,#0]            ;425
00031c  6800              LDR      r0,[r0,#0]            ;425
00031e  f0200008          BIC      r0,r0,#8              ;425
000322  6821              LDR      r1,[r4,#0]            ;425
000324  6008              STR      r0,[r1,#0]            ;425
                  |L15.806|
000326  7f60              LDRB     r0,[r4,#0x1d]         ;429
000328  2801              CMP      r0,#1                 ;429
00032a  d106              BNE      |L15.826|
00032c  6820              LDR      r0,[r4,#0]            ;431
00032e  6800              LDR      r0,[r0,#0]            ;431
000330  f0400004          ORR      r0,r0,#4              ;431
000334  6821              LDR      r1,[r4,#0]            ;431
000336  6008              STR      r0,[r1,#0]            ;431
000338  e005              B        |L15.838|
                  |L15.826|
00033a  6820              LDR      r0,[r4,#0]            ;435
00033c  6800              LDR      r0,[r0,#0]            ;435
00033e  f0200004          BIC      r0,r0,#4              ;435
000342  6821              LDR      r1,[r4,#0]            ;435
000344  6008              STR      r0,[r1,#0]            ;435
                  |L15.838|
000346  e9d40102          LDRD     r0,r1,[r4,#8]         ;439
00034a  4308              ORRS     r0,r0,r1              ;439
00034c  6921              LDR      r1,[r4,#0x10]         ;439
00034e  4308              ORRS     r0,r0,r1              ;439
000350  6961              LDR      r1,[r4,#0x14]         ;439
000352  4308              ORRS     r0,r0,r1              ;439
000354  6861              LDR      r1,[r4,#4]            ;439
000356  1e49              SUBS     r1,r1,#1              ;439
000358  4308              ORRS     r0,r0,r1              ;439
00035a  6821              LDR      r1,[r4,#0]            ;439
00035c  61c8              STR      r0,[r1,#0x1c]         ;439
00035e  2000              MOVS     r0,#0                 ;446
000360  6260              STR      r0,[r4,#0x24]         ;446
000362  2001              MOVS     r0,#1                 ;449
000364  f8840020          STRB     r0,[r4,#0x20]         ;449
000368  2000              MOVS     r0,#0                 ;452
00036a  e64d              B        |L15.8|
;;;454    
                          ENDP

                  |L15.876|
00036c  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
000370  73746d33
000374  32663478
000378  785f6861
00037c  6c5f6361
000380  6e2e6300
                  |L15.900|
                          DCD      HAL_CAN_RxFifo0MsgPendingCallback
                  |L15.904|
                          DCD      HAL_CAN_RxFifo0FullCallback
                  |L15.908|
                          DCD      HAL_CAN_RxFifo1MsgPendingCallback
                  |L15.912|
                          DCD      HAL_CAN_RxFifo1FullCallback
                  |L15.916|
                          DCD      HAL_CAN_TxMailbox0CompleteCallback
                  |L15.920|
                          DCD      HAL_CAN_TxMailbox1CompleteCallback
                  |L15.924|
                          DCD      HAL_CAN_TxMailbox2CompleteCallback
                  |L15.928|
                          DCD      HAL_CAN_TxMailbox0AbortCallback
                  |L15.932|
                          DCD      HAL_CAN_TxMailbox1AbortCallback
                  |L15.936|
                          DCD      HAL_CAN_TxMailbox2AbortCallback
                  |L15.940|
                          DCD      HAL_CAN_SleepCallback
                  |L15.944|
                          DCD      HAL_CAN_WakeUpFromRxMsgCallback
                  |L15.948|
                          DCD      HAL_CAN_ErrorCallback
                  |L15.952|
                          DCD      HAL_CAN_MspInit

                          AREA ||i.HAL_CAN_IsSleepActive||, CODE, READONLY, ALIGN=1

                  HAL_CAN_IsSleepActive PROC
;;;1221     */
;;;1222   uint32_t HAL_CAN_IsSleepActive(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;1223   {
;;;1224     uint32_t status = 0U;
000002  2000              MOVS     r0,#0
;;;1225     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8912020          LDRB     r2,[r1,#0x20]
;;;1226   
;;;1227     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L16.16|
;;;1228         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d105              BNE      |L16.28|
                  |L16.16|
;;;1229     {
;;;1230       /* Check Sleep mode */
;;;1231       if ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
000010  680b              LDR      r3,[r1,#0]
000012  685b              LDR      r3,[r3,#4]
000014  f0030302          AND      r3,r3,#2
000018  b103              CBZ      r3,|L16.28|
;;;1232       {
;;;1233         status = 1U;
00001a  2001              MOVS     r0,#1
                  |L16.28|
;;;1234       }
;;;1235     }
;;;1236   
;;;1237     /* Return function status */
;;;1238     return status;
;;;1239   }
00001c  4770              BX       lr
;;;1240   
                          ENDP


                          AREA ||i.HAL_CAN_IsTxMessagePending||, CODE, READONLY, ALIGN=2

                  HAL_CAN_IsTxMessagePending PROC
;;;1452     */
;;;1453   uint32_t HAL_CAN_IsTxMessagePending(CAN_HandleTypeDef *hcan, uint32_t TxMailboxes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1454   {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;1455     uint32_t status = 0U;
000008  2700              MOVS     r7,#0
;;;1456     HAL_CAN_StateTypeDef state = hcan->State;
00000a  f8956020          LDRB     r6,[r5,#0x20]
;;;1457   
;;;1458     /* Check function parameters */
;;;1459     assert_param(IS_CAN_TX_MAILBOX_LIST(TxMailboxes));
00000e  2c07              CMP      r4,#7
000010  d800              BHI      |L17.20|
000012  e004              B        |L17.30|
                  |L17.20|
000014  f24051b3          MOV      r1,#0x5b3
000018  a008              ADR      r0,|L17.60|
00001a  f7fffffe          BL       assert_failed
                  |L17.30|
;;;1460   
;;;1461     if ((state == HAL_CAN_STATE_READY) ||
00001e  2e01              CMP      r6,#1
000020  d001              BEQ      |L17.38|
;;;1462         (state == HAL_CAN_STATE_LISTENING))
000022  2e02              CMP      r6,#2
000024  d107              BNE      |L17.54|
                  |L17.38|
;;;1463     {
;;;1464       /* Check pending transmission request on the selected Tx Mailboxes */
;;;1465       if ((hcan->Instance->TSR & (TxMailboxes << CAN_TSR_TME0_Pos)) != (TxMailboxes << CAN_TSR_TME0_Pos))
000026  6828              LDR      r0,[r5,#0]
000028  6880              LDR      r0,[r0,#8]
00002a  ea006084          AND      r0,r0,r4,LSL #26
00002e  ebb06f84          CMP      r0,r4,LSL #26
000032  d000              BEQ      |L17.54|
;;;1466       {
;;;1467         status = 1U;
000034  2701              MOVS     r7,#1
                  |L17.54|
;;;1468       }
;;;1469     }
;;;1470   
;;;1471     /* Return status */
;;;1472     return status;
000036  4638              MOV      r0,r7
;;;1473   }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;1474   
                          ENDP

                  |L17.60|
00003c  5372635c          DCB      "Src\\stm32f4xx_hal_can.c",0
000040  73746d33
000044  32663478
000048  785f6861
00004c  6c5f6361
000050  6e2e6300

                          AREA ||i.HAL_CAN_MspDeInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspDeInit PROC
;;;524      */
;;;525    __weak void HAL_CAN_MspDeInit(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;526    {
;;;527      /* Prevent unused argument(s) compilation warning */
;;;528      UNUSED(hcan);
;;;529    
;;;530      /* NOTE : This function Should not be modified, when the callback is needed,
;;;531                the HAL_CAN_MspDeInit could be implemented in the user file
;;;532       */
;;;533    }
;;;534    
                          ENDP


                          AREA ||i.HAL_CAN_MspInit||, CODE, READONLY, ALIGN=1

                  HAL_CAN_MspInit PROC
;;;508      */
;;;509    __weak void HAL_CAN_MspInit(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;510    {
;;;511      /* Prevent unused argument(s) compilation warning */
;;;512      UNUSED(hcan);
;;;513    
;;;514      /* NOTE : This function Should not be modified, when the callback is needed,
;;;515                the HAL_CAN_MspInit could be implemented in the user file
;;;516       */
;;;517    }
;;;518    
                          ENDP


                          AREA ||i.HAL_CAN_RegisterCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RegisterCallback PROC
;;;560      */
;;;561    HAL_StatusTypeDef HAL_CAN_RegisterCallback(CAN_HandleTypeDef *hcan, HAL_CAN_CallbackIDTypeDef CallbackID, void (* pCallback)(CAN_HandleTypeDef *_hcan))
000000  b510              PUSH     {r4,lr}
;;;562    {
000002  4603              MOV      r3,r0
;;;563      HAL_StatusTypeDef status = HAL_OK;
000004  2400              MOVS     r4,#0
;;;564    
;;;565      if (pCallback == NULL)
000006  b92a              CBNZ     r2,|L20.20|
;;;566      {
;;;567        /* Update the error code */
;;;568        hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;
000008  6a58              LDR      r0,[r3,#0x24]
00000a  f4400080          ORR      r0,r0,#0x400000
00000e  6258              STR      r0,[r3,#0x24]
;;;569    
;;;570        return HAL_ERROR;
000010  2001              MOVS     r0,#1
                  |L20.18|
;;;571      }
;;;572    
;;;573      if (hcan->State == HAL_CAN_STATE_READY)
;;;574      {
;;;575        switch (CallbackID)
;;;576        {
;;;577          case HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID :
;;;578            hcan->TxMailbox0CompleteCallback = pCallback;
;;;579            break;
;;;580    
;;;581          case HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID :
;;;582            hcan->TxMailbox1CompleteCallback = pCallback;
;;;583            break;
;;;584    
;;;585          case HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID :
;;;586            hcan->TxMailbox2CompleteCallback = pCallback;
;;;587            break;
;;;588    
;;;589          case HAL_CAN_TX_MAILBOX0_ABORT_CB_ID :
;;;590            hcan->TxMailbox0AbortCallback = pCallback;
;;;591            break;
;;;592    
;;;593          case HAL_CAN_TX_MAILBOX1_ABORT_CB_ID :
;;;594            hcan->TxMailbox1AbortCallback = pCallback;
;;;595            break;
;;;596    
;;;597          case HAL_CAN_TX_MAILBOX2_ABORT_CB_ID :
;;;598            hcan->TxMailbox2AbortCallback = pCallback;
;;;599            break;
;;;600    
;;;601          case HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID :
;;;602            hcan->RxFifo0MsgPendingCallback = pCallback;
;;;603            break;
;;;604    
;;;605          case HAL_CAN_RX_FIFO0_FULL_CB_ID :
;;;606            hcan->RxFifo0FullCallback = pCallback;
;;;607            break;
;;;608    
;;;609          case HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID :
;;;610            hcan->RxFifo1MsgPendingCallback = pCallback;
;;;611            break;
;;;612    
;;;613          case HAL_CAN_RX_FIFO1_FULL_CB_ID :
;;;614            hcan->RxFifo1FullCallback = pCallback;
;;;615            break;
;;;616    
;;;617          case HAL_CAN_SLEEP_CB_ID :
;;;618            hcan->SleepCallback = pCallback;
;;;619            break;
;;;620    
;;;621          case HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID :
;;;622            hcan->WakeUpFromRxMsgCallback = pCallback;
;;;623            break;
;;;624    
;;;625          case HAL_CAN_ERROR_CB_ID :
;;;626            hcan->ErrorCallback = pCallback;
;;;627            break;
;;;628    
;;;629          case HAL_CAN_MSPINIT_CB_ID :
;;;630            hcan->MspInitCallback = pCallback;
;;;631            break;
;;;632    
;;;633          case HAL_CAN_MSPDEINIT_CB_ID :
;;;634            hcan->MspDeInitCallback = pCallback;
;;;635            break;
;;;636    
;;;637          default :
;;;638            /* Update the error code */
;;;639            hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;
;;;640    
;;;641            /* Return error status */
;;;642            status =  HAL_ERROR;
;;;643            break;
;;;644        }
;;;645      }
;;;646      else if (hcan->State == HAL_CAN_STATE_RESET)
;;;647      {
;;;648        switch (CallbackID)
;;;649        {
;;;650          case HAL_CAN_MSPINIT_CB_ID :
;;;651            hcan->MspInitCallback = pCallback;
;;;652            break;
;;;653    
;;;654          case HAL_CAN_MSPDEINIT_CB_ID :
;;;655            hcan->MspDeInitCallback = pCallback;
;;;656            break;
;;;657    
;;;658          default :
;;;659            /* Update the error code */
;;;660            hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;
;;;661    
;;;662            /* Return error status */
;;;663            status =  HAL_ERROR;
;;;664            break;
;;;665        }
;;;666      }
;;;667      else
;;;668      {
;;;669        /* Update the error code */
;;;670        hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;
;;;671    
;;;672        /* Return error status */
;;;673        status =  HAL_ERROR;
;;;674      }
;;;675    
;;;676      return status;
;;;677    }
000012  bd10              POP      {r4,pc}
                  |L20.20|
000014  f8930020          LDRB     r0,[r3,#0x20]         ;573
000018  2801              CMP      r0,#1                 ;573
00001a  d130              BNE      |L20.126|
00001c  290f              CMP      r1,#0xf               ;575
00001e  d227              BCS      |L20.112|
000020  e8dff001          TBB      [pc,r1]               ;575
000024  080a0c0e          DCB      0x08,0x0a,0x0c,0x0e
000028  10121416          DCB      0x10,0x12,0x14,0x16
00002c  181a1c1e          DCB      0x18,0x1a,0x1c,0x1e
000030  20222400          DCB      0x20,0x22,0x24,0x00
000034  629a              STR      r2,[r3,#0x28]         ;578
000036  e021              B        |L20.124|
000038  62da              STR      r2,[r3,#0x2c]         ;582
00003a  e01f              B        |L20.124|
00003c  631a              STR      r2,[r3,#0x30]         ;586
00003e  e01d              B        |L20.124|
000040  635a              STR      r2,[r3,#0x34]         ;590
000042  e01b              B        |L20.124|
000044  639a              STR      r2,[r3,#0x38]         ;594
000046  e019              B        |L20.124|
000048  63da              STR      r2,[r3,#0x3c]         ;598
00004a  e017              B        |L20.124|
00004c  641a              STR      r2,[r3,#0x40]         ;602
00004e  e015              B        |L20.124|
000050  645a              STR      r2,[r3,#0x44]         ;606
000052  e013              B        |L20.124|
000054  649a              STR      r2,[r3,#0x48]         ;610
000056  e011              B        |L20.124|
000058  64da              STR      r2,[r3,#0x4c]         ;614
00005a  e00f              B        |L20.124|
00005c  651a              STR      r2,[r3,#0x50]         ;618
00005e  e00d              B        |L20.124|
000060  655a              STR      r2,[r3,#0x54]         ;622
000062  e00b              B        |L20.124|
000064  659a              STR      r2,[r3,#0x58]         ;626
000066  e009              B        |L20.124|
000068  65da              STR      r2,[r3,#0x5c]         ;630
00006a  e007              B        |L20.124|
00006c  661a              STR      r2,[r3,#0x60]         ;634
00006e  e005              B        |L20.124|
                  |L20.112|
000070  6a58              LDR      r0,[r3,#0x24]         ;639
000072  f4400080          ORR      r0,r0,#0x400000       ;639
000076  6258              STR      r0,[r3,#0x24]         ;639
000078  2401              MOVS     r4,#1                 ;642
00007a  bf00              NOP                            ;643
                  |L20.124|
00007c  e017              B        |L20.174|
                  |L20.126|
00007e  f8930020          LDRB     r0,[r3,#0x20]         ;646
000082  b978              CBNZ     r0,|L20.164|
000084  290d              CMP      r1,#0xd               ;648
000086  d002              BEQ      |L20.142|
000088  290e              CMP      r1,#0xe               ;648
00008a  d104              BNE      |L20.150|
00008c  e001              B        |L20.146|
                  |L20.142|
00008e  65da              STR      r2,[r3,#0x5c]         ;651
000090  e007              B        |L20.162|
                  |L20.146|
000092  661a              STR      r2,[r3,#0x60]         ;655
000094  e005              B        |L20.162|
                  |L20.150|
000096  6a58              LDR      r0,[r3,#0x24]         ;660
000098  f4400080          ORR      r0,r0,#0x400000       ;660
00009c  6258              STR      r0,[r3,#0x24]         ;660
00009e  2401              MOVS     r4,#1                 ;663
0000a0  bf00              NOP                            ;664
                  |L20.162|
0000a2  e004              B        |L20.174|
                  |L20.164|
0000a4  6a58              LDR      r0,[r3,#0x24]         ;670
0000a6  f4400080          ORR      r0,r0,#0x400000       ;670
0000aa  6258              STR      r0,[r3,#0x24]         ;670
0000ac  2401              MOVS     r4,#1                 ;673
                  |L20.174|
0000ae  4620              MOV      r0,r4                 ;676
0000b0  e7af              B        |L20.18|
;;;678    
                          ENDP


                          AREA ||i.HAL_CAN_RequestSleep||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RequestSleep PROC
;;;1141     */
;;;1142   HAL_StatusTypeDef HAL_CAN_RequestSleep(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;1143   {
;;;1144     HAL_CAN_StateTypeDef state = hcan->State;
000002  f8912020          LDRB     r2,[r1,#0x20]
;;;1145   
;;;1146     if ((state == HAL_CAN_STATE_READY) ||
000006  2a01              CMP      r2,#1
000008  d001              BEQ      |L21.14|
;;;1147         (state == HAL_CAN_STATE_LISTENING))
00000a  2a02              CMP      r2,#2
00000c  d107              BNE      |L21.30|
                  |L21.14|
;;;1148     {
;;;1149       /* Request Sleep mode */
;;;1150       SET_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
00000e  6808              LDR      r0,[r1,#0]
000010  6800              LDR      r0,[r0,#0]
000012  f0400002          ORR      r0,r0,#2
000016  680b              LDR      r3,[r1,#0]
000018  6018              STR      r0,[r3,#0]
;;;1151   
;;;1152       /* Return function status */
;;;1153       return HAL_OK;
00001a  2000              MOVS     r0,#0
                  |L21.28|
;;;1154     }
;;;1155     else
;;;1156     {
;;;1157       /* Update error code */
;;;1158       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1159   
;;;1160       /* Return function status */
;;;1161       return HAL_ERROR;
;;;1162     }
;;;1163   }
00001c  4770              BX       lr
                  |L21.30|
00001e  6a48              LDR      r0,[r1,#0x24]         ;1158
000020  f4402080          ORR      r0,r0,#0x40000        ;1158
000024  6248              STR      r0,[r1,#0x24]         ;1158
000026  2001              MOVS     r0,#1                 ;1161
000028  e7f8              B        |L21.28|
;;;1164   
                          ENDP


                          AREA ||i.HAL_CAN_ResetError||, CODE, READONLY, ALIGN=1

                  HAL_CAN_ResetError PROC
;;;2423     */
;;;2424   HAL_StatusTypeDef HAL_CAN_ResetError(CAN_HandleTypeDef *hcan)
000000  4601              MOV      r1,r0
;;;2425   {
;;;2426     HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;2427     HAL_CAN_StateTypeDef state = hcan->State;
000004  f8912020          LDRB     r2,[r1,#0x20]
;;;2428   
;;;2429     if ((state == HAL_CAN_STATE_READY) ||
000008  2a01              CMP      r2,#1
00000a  d001              BEQ      |L22.16|
;;;2430         (state == HAL_CAN_STATE_LISTENING))
00000c  2a02              CMP      r2,#2
00000e  d102              BNE      |L22.22|
                  |L22.16|
;;;2431     {
;;;2432       /* Reset CAN error code */
;;;2433       hcan->ErrorCode = 0U;
000010  2300              MOVS     r3,#0
000012  624b              STR      r3,[r1,#0x24]
000014  e004              B        |L22.32|
                  |L22.22|
;;;2434     }
;;;2435     else
;;;2436     {
;;;2437       /* Update error code */
;;;2438       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
000016  6a4b              LDR      r3,[r1,#0x24]
000018  f4432380          ORR      r3,r3,#0x40000
00001c  624b              STR      r3,[r1,#0x24]
;;;2439   
;;;2440       status = HAL_ERROR;
00001e  2001              MOVS     r0,#1
                  |L22.32|
;;;2441     }
;;;2442   
;;;2443     /* Return the status */
;;;2444     return status;
;;;2445   }
000020  4770              BX       lr
;;;2446   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo0FullCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo0FullCallback PROC
;;;2255     */
;;;2256   __weak void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2257   {
;;;2258     /* Prevent unused argument(s) compilation warning */
;;;2259     UNUSED(hcan);
;;;2260   
;;;2261     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2262               the HAL_CAN_RxFifo0FullCallback could be implemented in the user
;;;2263               file
;;;2264      */
;;;2265   }
;;;2266   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo0MsgPendingCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo0MsgPendingCallback PROC
;;;2238     */
;;;2239   __weak void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2240   {
;;;2241     /* Prevent unused argument(s) compilation warning */
;;;2242     UNUSED(hcan);
;;;2243   
;;;2244     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2245               the HAL_CAN_RxFifo0MsgPendingCallback could be implemented in the
;;;2246               user file
;;;2247      */
;;;2248   }
;;;2249   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo1FullCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo1FullCallback PROC
;;;2289     */
;;;2290   __weak void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2291   {
;;;2292     /* Prevent unused argument(s) compilation warning */
;;;2293     UNUSED(hcan);
;;;2294   
;;;2295     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2296               the HAL_CAN_RxFifo1FullCallback could be implemented in the user
;;;2297               file
;;;2298      */
;;;2299   }
;;;2300   
                          ENDP


                          AREA ||i.HAL_CAN_RxFifo1MsgPendingCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_RxFifo1MsgPendingCallback PROC
;;;2272     */
;;;2273   __weak void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2274   {
;;;2275     /* Prevent unused argument(s) compilation warning */
;;;2276     UNUSED(hcan);
;;;2277   
;;;2278     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2279               the HAL_CAN_RxFifo1MsgPendingCallback could be implemented in the
;;;2280               user file
;;;2281      */
;;;2282   }
;;;2283   
                          ENDP


                          AREA ||i.HAL_CAN_SleepCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_SleepCallback PROC
;;;2306     */
;;;2307   __weak void HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2308   {
;;;2309     /* Prevent unused argument(s) compilation warning */
;;;2310     UNUSED(hcan);
;;;2311   
;;;2312     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2313               the HAL_CAN_SleepCallback could be implemented in the user file
;;;2314      */
;;;2315   }
;;;2316   
                          ENDP


                          AREA ||i.HAL_CAN_Start||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Start PROC
;;;1034     */
;;;1035   HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;1036   {
000002  4604              MOV      r4,r0
;;;1037     uint32_t tickstart;
;;;1038   
;;;1039     if (hcan->State == HAL_CAN_STATE_READY)
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2801              CMP      r0,#1
00000a  d122              BNE      |L28.82|
;;;1040     {
;;;1041       /* Change CAN peripheral state */
;;;1042       hcan->State = HAL_CAN_STATE_LISTENING;
00000c  2002              MOVS     r0,#2
00000e  f8840020          STRB     r0,[r4,#0x20]
;;;1043   
;;;1044       /* Request leave initialisation */
;;;1045       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
000012  6820              LDR      r0,[r4,#0]
000014  6800              LDR      r0,[r0,#0]
000016  f0200001          BIC      r0,r0,#1
00001a  6821              LDR      r1,[r4,#0]
00001c  6008              STR      r0,[r1,#0]
;;;1046   
;;;1047       /* Get tick */
;;;1048       tickstart = HAL_GetTick();
00001e  f7fffffe          BL       SysTick_GetTick
000022  4605              MOV      r5,r0
;;;1049   
;;;1050       /* Wait the acknowledge */
;;;1051       while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
000024  e00d              B        |L28.66|
                  |L28.38|
;;;1052       {
;;;1053         /* Check for the Timeout */
;;;1054         if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
000026  f7fffffe          BL       SysTick_GetTick
00002a  1b40              SUBS     r0,r0,r5
00002c  280a              CMP      r0,#0xa
00002e  d908              BLS      |L28.66|
;;;1055         {
;;;1056           /* Update error code */
;;;1057           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
000030  6a60              LDR      r0,[r4,#0x24]
000032  f4403000          ORR      r0,r0,#0x20000
000036  6260              STR      r0,[r4,#0x24]
;;;1058   
;;;1059           /* Change CAN state */
;;;1060           hcan->State = HAL_CAN_STATE_ERROR;
000038  2005              MOVS     r0,#5
00003a  f8840020          STRB     r0,[r4,#0x20]
;;;1061   
;;;1062           return HAL_ERROR;
00003e  2001              MOVS     r0,#1
                  |L28.64|
;;;1063         }
;;;1064       }
;;;1065   
;;;1066       /* Reset the CAN ErrorCode */
;;;1067       hcan->ErrorCode = HAL_CAN_ERROR_NONE;
;;;1068   
;;;1069       /* Return function status */
;;;1070       return HAL_OK;
;;;1071     }
;;;1072     else
;;;1073     {
;;;1074       /* Update error code */
;;;1075       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
;;;1076   
;;;1077       return HAL_ERROR;
;;;1078     }
;;;1079   }
000040  bd70              POP      {r4-r6,pc}
                  |L28.66|
000042  6820              LDR      r0,[r4,#0]            ;1051
000044  6840              LDR      r0,[r0,#4]            ;1051
000046  f0000001          AND      r0,r0,#1              ;1051
00004a  2800              CMP      r0,#0                 ;1051
00004c  d1eb              BNE      |L28.38|
00004e  6260              STR      r0,[r4,#0x24]         ;1067
000050  e7f6              B        |L28.64|
                  |L28.82|
000052  6a60              LDR      r0,[r4,#0x24]         ;1075
000054  f4402000          ORR      r0,r0,#0x80000        ;1075
000058  6260              STR      r0,[r4,#0x24]         ;1075
00005a  2001              MOVS     r0,#1                 ;1077
00005c  e7f0              B        |L28.64|
;;;1080   
                          ENDP


                          AREA ||i.HAL_CAN_Stop||, CODE, READONLY, ALIGN=1

                  HAL_CAN_Stop PROC
;;;1086     */
;;;1087   HAL_StatusTypeDef HAL_CAN_Stop(CAN_HandleTypeDef *hcan)
000000  b570              PUSH     {r4-r6,lr}
;;;1088   {
000002  4604              MOV      r4,r0
;;;1089     uint32_t tickstart;
;;;1090   
;;;1091     if (hcan->State == HAL_CAN_STATE_LISTENING)
000004  f8940020          LDRB     r0,[r4,#0x20]
000008  2802              CMP      r0,#2
00000a  d128              BNE      |L29.94|
;;;1092     {
;;;1093       /* Request initialisation */
;;;1094       SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
00000c  6820              LDR      r0,[r4,#0]
00000e  6800              LDR      r0,[r0,#0]
000010  f0400001          ORR      r0,r0,#1
000014  6821              LDR      r1,[r4,#0]
000016  6008              STR      r0,[r1,#0]
;;;1095   
;;;1096       /* Get tick */
;;;1097       tickstart = HAL_GetTick();
000018  f7fffffe          BL       SysTick_GetTick
00001c  4605              MOV      r5,r0
;;;1098   
;;;1099       /* Wait the acknowledge */
;;;1100       while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
00001e  e00d              B        |L29.60|
                  |L29.32|
;;;1101       {
;;;1102         /* Check for the Timeout */
;;;1103         if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
000020  f7fffffe          BL       SysTick_GetTick
000024  1b40              SUBS     r0,r0,r5
000026  280a              CMP      r0,#0xa
000028  d908              BLS      |L29.60|
;;;1104         {
;;;1105           /* Update error code */
;;;1106           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
00002a  6a60              LDR      r0,[r4,#0x24]
00002c  f4403000          ORR      r0,r0,#0x20000
000030  6260              STR      r0,[r4,#0x24]
;;;1107   
;;;1108           /* Change CAN state */
;;;1109           hcan->State = HAL_CAN_STATE_ERROR;
000032  2005              MOVS     r0,#5
000034  f8840020          STRB     r0,[r4,#0x20]
;;;1110   
;;;1111           return HAL_ERROR;
000038  2001              MOVS     r0,#1
                  |L29.58|
;;;1112         }
;;;1113       }
;;;1114   
;;;1115       /* Exit from sleep mode */
;;;1116       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
;;;1117   
;;;1118       /* Change CAN peripheral state */
;;;1119       hcan->State = HAL_CAN_STATE_READY;
;;;1120   
;;;1121       /* Return function status */
;;;1122       return HAL_OK;
;;;1123     }
;;;1124     else
;;;1125     {
;;;1126       /* Update error code */
;;;1127       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_STARTED;
;;;1128   
;;;1129       return HAL_ERROR;
;;;1130     }
;;;1131   }
00003a  bd70              POP      {r4-r6,pc}
                  |L29.60|
00003c  6820              LDR      r0,[r4,#0]            ;1100
00003e  6840              LDR      r0,[r0,#4]            ;1100
000040  f0000001          AND      r0,r0,#1              ;1100
000044  2800              CMP      r0,#0                 ;1100
000046  d0eb              BEQ      |L29.32|
000048  6820              LDR      r0,[r4,#0]            ;1116
00004a  6800              LDR      r0,[r0,#0]            ;1116
00004c  f0200002          BIC      r0,r0,#2              ;1116
000050  6821              LDR      r1,[r4,#0]            ;1116
000052  6008              STR      r0,[r1,#0]            ;1116
000054  2001              MOVS     r0,#1                 ;1119
000056  f8840020          STRB     r0,[r4,#0x20]         ;1119
00005a  2000              MOVS     r0,#0                 ;1122
00005c  e7ed              B        |L29.58|
                  |L29.94|
00005e  6a60              LDR      r0,[r4,#0x24]         ;1127
000060  f4401080          ORR      r0,r0,#0x100000       ;1127
000064  6260              STR      r0,[r4,#0x24]         ;1127
000066  2001              MOVS     r0,#1                 ;1129
000068  e7e7              B        |L29.58|
;;;1132   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox0AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox0AbortCallback PROC
;;;2187     */
;;;2188   __weak void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2189   {
;;;2190     /* Prevent unused argument(s) compilation warning */
;;;2191     UNUSED(hcan);
;;;2192   
;;;2193     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2194               the HAL_CAN_TxMailbox0AbortCallback could be implemented in the
;;;2195               user file
;;;2196      */
;;;2197   }
;;;2198   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox0CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox0CompleteCallback PROC
;;;2136     */
;;;2137   __weak void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2138   {
;;;2139     /* Prevent unused argument(s) compilation warning */
;;;2140     UNUSED(hcan);
;;;2141   
;;;2142     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2143               the HAL_CAN_TxMailbox0CompleteCallback could be implemented in the
;;;2144               user file
;;;2145      */
;;;2146   }
;;;2147   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox1AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox1AbortCallback PROC
;;;2204     */
;;;2205   __weak void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2206   {
;;;2207     /* Prevent unused argument(s) compilation warning */
;;;2208     UNUSED(hcan);
;;;2209   
;;;2210     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2211               the HAL_CAN_TxMailbox1AbortCallback could be implemented in the
;;;2212               user file
;;;2213      */
;;;2214   }
;;;2215   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox1CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox1CompleteCallback PROC
;;;2153     */
;;;2154   __weak void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2155   {
;;;2156     /* Prevent unused argument(s) compilation warning */
;;;2157     UNUSED(hcan);
;;;2158   
;;;2159     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2160               the HAL_CAN_TxMailbox1CompleteCallback could be implemented in the
;;;2161               user file
;;;2162      */
;;;2163   }
;;;2164   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox2AbortCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox2AbortCallback PROC
;;;2221     */
;;;2222   __weak void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2223   {
;;;2224     /* Prevent unused argument(s) compilation warning */
;;;2225     UNUSED(hcan);
;;;2226   
;;;2227     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2228               the HAL_CAN_TxMailbox2AbortCallback could be implemented in the
;;;2229               user file
;;;2230      */
;;;2231   }
;;;2232   
                          ENDP


                          AREA ||i.HAL_CAN_TxMailbox2CompleteCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_TxMailbox2CompleteCallback PROC
;;;2170     */
;;;2171   __weak void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2172   {
;;;2173     /* Prevent unused argument(s) compilation warning */
;;;2174     UNUSED(hcan);
;;;2175   
;;;2176     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2177               the HAL_CAN_TxMailbox2CompleteCallback could be implemented in the
;;;2178               user file
;;;2179      */
;;;2180   }
;;;2181   
                          ENDP


                          AREA ||i.HAL_CAN_UnRegisterCallback||, CODE, READONLY, ALIGN=2

                  HAL_CAN_UnRegisterCallback PROC
;;;702      */
;;;703    HAL_StatusTypeDef HAL_CAN_UnRegisterCallback(CAN_HandleTypeDef *hcan, HAL_CAN_CallbackIDTypeDef CallbackID)
000000  4602              MOV      r2,r0
;;;704    {
;;;705      HAL_StatusTypeDef status = HAL_OK;
000002  2000              MOVS     r0,#0
;;;706    
;;;707      if (hcan->State == HAL_CAN_STATE_READY)
000004  f8923020          LDRB     r3,[r2,#0x20]
000008  2b01              CMP      r3,#1
00000a  d13f              BNE      |L36.140|
;;;708      {
;;;709        switch (CallbackID)
00000c  290f              CMP      r1,#0xf
00000e  d236              BCS      |L36.126|
000010  e8dff001          TBB      [pc,r1]
000014  080b0e11          DCB      0x08,0x0b,0x0e,0x11
000018  14171a1d          DCB      0x14,0x17,0x1a,0x1d
00001c  20232629          DCB      0x20,0x23,0x26,0x29
000020  2c2f3200          DCB      0x2c,0x2f,0x32,0x00
;;;710        {
;;;711          case HAL_CAN_TX_MAILBOX0_COMPLETE_CB_ID :
;;;712            hcan->TxMailbox0CompleteCallback = HAL_CAN_TxMailbox0CompleteCallback;
000024  4b27              LDR      r3,|L36.196|
000026  6293              STR      r3,[r2,#0x28]
;;;713            break;
000028  e02f              B        |L36.138|
;;;714    
;;;715          case HAL_CAN_TX_MAILBOX1_COMPLETE_CB_ID :
;;;716            hcan->TxMailbox1CompleteCallback = HAL_CAN_TxMailbox1CompleteCallback;
00002a  4b27              LDR      r3,|L36.200|
00002c  62d3              STR      r3,[r2,#0x2c]
;;;717            break;
00002e  e02c              B        |L36.138|
;;;718    
;;;719          case HAL_CAN_TX_MAILBOX2_COMPLETE_CB_ID :
;;;720            hcan->TxMailbox2CompleteCallback = HAL_CAN_TxMailbox2CompleteCallback;
000030  4b26              LDR      r3,|L36.204|
000032  6313              STR      r3,[r2,#0x30]
;;;721            break;
000034  e029              B        |L36.138|
;;;722    
;;;723          case HAL_CAN_TX_MAILBOX0_ABORT_CB_ID :
;;;724            hcan->TxMailbox0AbortCallback = HAL_CAN_TxMailbox0AbortCallback;
000036  4b26              LDR      r3,|L36.208|
000038  6353              STR      r3,[r2,#0x34]
;;;725            break;
00003a  e026              B        |L36.138|
;;;726    
;;;727          case HAL_CAN_TX_MAILBOX1_ABORT_CB_ID :
;;;728            hcan->TxMailbox1AbortCallback = HAL_CAN_TxMailbox1AbortCallback;
00003c  4b25              LDR      r3,|L36.212|
00003e  6393              STR      r3,[r2,#0x38]
;;;729            break;
000040  e023              B        |L36.138|
;;;730    
;;;731          case HAL_CAN_TX_MAILBOX2_ABORT_CB_ID :
;;;732            hcan->TxMailbox2AbortCallback = HAL_CAN_TxMailbox2AbortCallback;
000042  4b25              LDR      r3,|L36.216|
000044  63d3              STR      r3,[r2,#0x3c]
;;;733            break;
000046  e020              B        |L36.138|
;;;734    
;;;735          case HAL_CAN_RX_FIFO0_MSG_PENDING_CB_ID :
;;;736            hcan->RxFifo0MsgPendingCallback = HAL_CAN_RxFifo0MsgPendingCallback;
000048  4b24              LDR      r3,|L36.220|
00004a  6413              STR      r3,[r2,#0x40]
;;;737            break;
00004c  e01d              B        |L36.138|
;;;738    
;;;739          case HAL_CAN_RX_FIFO0_FULL_CB_ID :
;;;740            hcan->RxFifo0FullCallback = HAL_CAN_RxFifo0FullCallback;
00004e  4b24              LDR      r3,|L36.224|
000050  6453              STR      r3,[r2,#0x44]
;;;741            break;
000052  e01a              B        |L36.138|
;;;742    
;;;743          case HAL_CAN_RX_FIFO1_MSG_PENDING_CB_ID :
;;;744            hcan->RxFifo1MsgPendingCallback = HAL_CAN_RxFifo1MsgPendingCallback;
000054  4b23              LDR      r3,|L36.228|
000056  6493              STR      r3,[r2,#0x48]
;;;745            break;
000058  e017              B        |L36.138|
;;;746    
;;;747          case HAL_CAN_RX_FIFO1_FULL_CB_ID :
;;;748            hcan->RxFifo1FullCallback = HAL_CAN_RxFifo1FullCallback;
00005a  4b23              LDR      r3,|L36.232|
00005c  64d3              STR      r3,[r2,#0x4c]
;;;749            break;
00005e  e014              B        |L36.138|
;;;750    
;;;751          case HAL_CAN_SLEEP_CB_ID :
;;;752            hcan->SleepCallback = HAL_CAN_SleepCallback;
000060  4b22              LDR      r3,|L36.236|
000062  6513              STR      r3,[r2,#0x50]
;;;753            break;
000064  e011              B        |L36.138|
;;;754    
;;;755          case HAL_CAN_WAKEUP_FROM_RX_MSG_CB_ID :
;;;756            hcan->WakeUpFromRxMsgCallback = HAL_CAN_WakeUpFromRxMsgCallback;
000066  4b22              LDR      r3,|L36.240|
000068  6553              STR      r3,[r2,#0x54]
;;;757            break;
00006a  e00e              B        |L36.138|
;;;758    
;;;759          case HAL_CAN_ERROR_CB_ID :
;;;760            hcan->ErrorCallback = HAL_CAN_ErrorCallback;
00006c  4b21              LDR      r3,|L36.244|
00006e  6593              STR      r3,[r2,#0x58]
;;;761            break;
000070  e00b              B        |L36.138|
;;;762    
;;;763          case HAL_CAN_MSPINIT_CB_ID :
;;;764            hcan->MspInitCallback = HAL_CAN_MspInit;
000072  4b21              LDR      r3,|L36.248|
000074  65d3              STR      r3,[r2,#0x5c]
;;;765            break;
000076  e008              B        |L36.138|
;;;766    
;;;767          case HAL_CAN_MSPDEINIT_CB_ID :
;;;768            hcan->MspDeInitCallback = HAL_CAN_MspDeInit;
000078  4b20              LDR      r3,|L36.252|
00007a  6613              STR      r3,[r2,#0x60]
;;;769            break;
00007c  e005              B        |L36.138|
                  |L36.126|
;;;770    
;;;771          default :
;;;772            /* Update the error code */
;;;773            hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;
00007e  6a53              LDR      r3,[r2,#0x24]
000080  f4430380          ORR      r3,r3,#0x400000
000084  6253              STR      r3,[r2,#0x24]
;;;774    
;;;775            /* Return error status */
;;;776            status =  HAL_ERROR;
000086  2001              MOVS     r0,#1
;;;777            break;
000088  bf00              NOP      
                  |L36.138|
00008a  e019              B        |L36.192|
                  |L36.140|
;;;778        }
;;;779      }
;;;780      else if (hcan->State == HAL_CAN_STATE_RESET)
00008c  f8923020          LDRB     r3,[r2,#0x20]
000090  b98b              CBNZ     r3,|L36.182|
;;;781      {
;;;782        switch (CallbackID)
000092  290d              CMP      r1,#0xd
000094  d002              BEQ      |L36.156|
000096  290e              CMP      r1,#0xe
000098  d106              BNE      |L36.168|
00009a  e002              B        |L36.162|
                  |L36.156|
;;;783        {
;;;784          case HAL_CAN_MSPINIT_CB_ID :
;;;785            hcan->MspInitCallback = HAL_CAN_MspInit;
00009c  4b16              LDR      r3,|L36.248|
00009e  65d3              STR      r3,[r2,#0x5c]
;;;786            break;
0000a0  e008              B        |L36.180|
                  |L36.162|
;;;787    
;;;788          case HAL_CAN_MSPDEINIT_CB_ID :
;;;789            hcan->MspDeInitCallback = HAL_CAN_MspDeInit;
0000a2  4b16              LDR      r3,|L36.252|
0000a4  6613              STR      r3,[r2,#0x60]
;;;790            break;
0000a6  e005              B        |L36.180|
                  |L36.168|
;;;791    
;;;792          default :
;;;793            /* Update the error code */
;;;794            hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;
0000a8  6a53              LDR      r3,[r2,#0x24]
0000aa  f4430380          ORR      r3,r3,#0x400000
0000ae  6253              STR      r3,[r2,#0x24]
;;;795    
;;;796            /* Return error status */
;;;797            status =  HAL_ERROR;
0000b0  2001              MOVS     r0,#1
;;;798            break;
0000b2  bf00              NOP      
                  |L36.180|
0000b4  e004              B        |L36.192|
                  |L36.182|
;;;799        }
;;;800      }
;;;801      else
;;;802      {
;;;803        /* Update the error code */
;;;804        hcan->ErrorCode |= HAL_CAN_ERROR_INVALID_CALLBACK;
0000b6  6a53              LDR      r3,[r2,#0x24]
0000b8  f4430380          ORR      r3,r3,#0x400000
0000bc  6253              STR      r3,[r2,#0x24]
;;;805    
;;;806        /* Return error status */
;;;807        status =  HAL_ERROR;
0000be  2001              MOVS     r0,#1
                  |L36.192|
;;;808      }
;;;809    
;;;810      return status;
;;;811    }
0000c0  4770              BX       lr
;;;812    #endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
                          ENDP

0000c2  0000              DCW      0x0000
                  |L36.196|
                          DCD      HAL_CAN_TxMailbox0CompleteCallback
                  |L36.200|
                          DCD      HAL_CAN_TxMailbox1CompleteCallback
                  |L36.204|
                          DCD      HAL_CAN_TxMailbox2CompleteCallback
                  |L36.208|
                          DCD      HAL_CAN_TxMailbox0AbortCallback
                  |L36.212|
                          DCD      HAL_CAN_TxMailbox1AbortCallback
                  |L36.216|
                          DCD      HAL_CAN_TxMailbox2AbortCallback
                  |L36.220|
                          DCD      HAL_CAN_RxFifo0MsgPendingCallback
                  |L36.224|
                          DCD      HAL_CAN_RxFifo0FullCallback
                  |L36.228|
                          DCD      HAL_CAN_RxFifo1MsgPendingCallback
                  |L36.232|
                          DCD      HAL_CAN_RxFifo1FullCallback
                  |L36.236|
                          DCD      HAL_CAN_SleepCallback
                  |L36.240|
                          DCD      HAL_CAN_WakeUpFromRxMsgCallback
                  |L36.244|
                          DCD      HAL_CAN_ErrorCallback
                  |L36.248|
                          DCD      HAL_CAN_MspInit
                  |L36.252|
                          DCD      HAL_CAN_MspDeInit

                          AREA ||i.HAL_CAN_WakeUp||, CODE, READONLY, ALIGN=2

                  HAL_CAN_WakeUp PROC
;;;1172     */
;;;1173   HAL_StatusTypeDef HAL_CAN_WakeUp(CAN_HandleTypeDef *hcan)
000000  b518              PUSH     {r3,r4,lr}
;;;1174   {
000002  4601              MOV      r1,r0
;;;1175     __IO uint32_t count = 0;
000004  2000              MOVS     r0,#0
000006  9000              STR      r0,[sp,#0]
;;;1176     uint32_t timeout = 1000000U;
000008  4b13              LDR      r3,|L37.88|
;;;1177     HAL_CAN_StateTypeDef state = hcan->State;
00000a  f8912020          LDRB     r2,[r1,#0x20]
;;;1178   
;;;1179     if ((state == HAL_CAN_STATE_READY) ||
00000e  2a01              CMP      r2,#1
000010  d001              BEQ      |L37.22|
;;;1180         (state == HAL_CAN_STATE_LISTENING))
000012  2a02              CMP      r2,#2
000014  d119              BNE      |L37.74|
                  |L37.22|
;;;1181     {
;;;1182       /* Wake up request */
;;;1183       CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
000016  6808              LDR      r0,[r1,#0]
000018  6800              LDR      r0,[r0,#0]
00001a  f0200002          BIC      r0,r0,#2
00001e  680c              LDR      r4,[r1,#0]
000020  6020              STR      r0,[r4,#0]
;;;1184   
;;;1185       /* Wait sleep mode is exited */
;;;1186       do
000022  bf00              NOP      
                  |L37.36|
;;;1187       {
;;;1188         /* Increment counter */
;;;1189         count++;
000024  9800              LDR      r0,[sp,#0]
000026  1c40              ADDS     r0,r0,#1
000028  9000              STR      r0,[sp,#0]
;;;1190   
;;;1191         /* Check if timeout is reached */
;;;1192         if (count > timeout)
00002a  9800              LDR      r0,[sp,#0]
00002c  4298              CMP      r0,r3
00002e  d905              BLS      |L37.60|
;;;1193         {
;;;1194           /* Update error code */
;;;1195           hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
000030  6a48              LDR      r0,[r1,#0x24]
000032  f4403000          ORR      r0,r0,#0x20000
000036  6248              STR      r0,[r1,#0x24]
;;;1196   
;;;1197           return HAL_ERROR;
000038  2001              MOVS     r0,#1
                  |L37.58|
;;;1198         }
;;;1199       }
;;;1200       while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U);
;;;1201   
;;;1202       /* Return function status */
;;;1203       return HAL_OK;
;;;1204     }
;;;1205     else
;;;1206     {
;;;1207       /* Update error code */
;;;1208       hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
;;;1209   
;;;1210       return HAL_ERROR;
;;;1211     }
;;;1212   }
00003a  bd18              POP      {r3,r4,pc}
                  |L37.60|
00003c  6808              LDR      r0,[r1,#0]            ;1200
00003e  6840              LDR      r0,[r0,#4]            ;1200
000040  f0000002          AND      r0,r0,#2              ;1200
000044  2800              CMP      r0,#0                 ;1200
000046  d1ed              BNE      |L37.36|
000048  e7f7              B        |L37.58|
                  |L37.74|
00004a  6a48              LDR      r0,[r1,#0x24]         ;1208
00004c  f4402080          ORR      r0,r0,#0x40000        ;1208
000050  6248              STR      r0,[r1,#0x24]         ;1208
000052  2001              MOVS     r0,#1                 ;1210
000054  e7f1              B        |L37.58|
;;;1213   
                          ENDP

000056  0000              DCW      0x0000
                  |L37.88|
                          DCD      0x000f4240

                          AREA ||i.HAL_CAN_WakeUpFromRxMsgCallback||, CODE, READONLY, ALIGN=1

                  HAL_CAN_WakeUpFromRxMsgCallback PROC
;;;2322     */
;;;2323   __weak void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)
000000  4770              BX       lr
;;;2324   {
;;;2325     /* Prevent unused argument(s) compilation warning */
;;;2326     UNUSED(hcan);
;;;2327   
;;;2328     /* NOTE : This function Should not be modified, when the callback is needed,
;;;2329               the HAL_CAN_WakeUpFromRxMsgCallback could be implemented in the
;;;2330               user file
;;;2331      */
;;;2332   }
;;;2333   
                          ENDP


;*** Start embedded assembler ***

#line 1 "Src\\stm32f4xx_hal_can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_can_c_fe6cb454____REV16|
#line 492 "D:\\Users\\Laurent\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___19_stm32f4xx_hal_can_c_fe6cb454____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_can_c_fe6cb454____REVSH|
#line 507
|__asm___19_stm32f4xx_hal_can_c_fe6cb454____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_stm32f4xx_hal_can_c_fe6cb454____RRX|
#line 694
|__asm___19_stm32f4xx_hal_can_c_fe6cb454____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
