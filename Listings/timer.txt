; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timer.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\Inc -I.\System_Files -I.\RTE\_NucleoF446xx -ID:\Users\Laurent\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -ID:\Users\Laurent\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=529 -D_RTE_ -DSTM32F446xx -D_DEBUG -DUSE_HAL_CAN_REGISTER_CALLBACKS --omf_browse=.\objects\timer.crf Src\timer.c]
                          THUMB

                          AREA ||i.DefaultFunc||, CODE, READONLY, ALIGN=2

                  DefaultFunc PROC
;;;50      */
;;;51     void DefaultFunc( TIM_TypeDef *ptr )
000000  b510              PUSH     {r4,lr}
;;;52     {
000002  4604              MOV      r4,r0
;;;53     	assert_failed(__FILE__,__LINE__);
000004  2135              MOVS     r1,#0x35
000006  a002              ADR      r0,|L1.16|
000008  f7fffffe          BL       assert_failed
;;;54     }
00000c  bd10              POP      {r4,pc}
;;;55     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
000010  5372635c          DCB      "Src\\timer.c",0
000014  74696d65
000018  722e6300

                          AREA ||i.TIM1_BRK_TIM9_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_BRK_TIM9_IRQHandler PROC
;;;585     */
;;;586    void TIM1_BRK_TIM9_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;587    {
;;;588    	  timer_callback[TIM9_index](TIM9);
000002  4802              LDR      r0,|L2.12|
000004  6a41              LDR      r1,[r0,#0x24]  ; timer_callback
000006  4802              LDR      r0,|L2.16|
000008  4788              BLX      r1
;;;589    }
00000a  bd10              POP      {r4,pc}
;;;590    
                          ENDP

                  |L2.12|
                          DCD      timer_callback
                  |L2.16|
                          DCD      0x40014000

                          AREA ||i.TIM1_CC_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_CC_IRQHandler PROC
;;;449     */
;;;450    void TIM1_CC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;451    {
;;;452    	  timer_callback[TIM1_index](TIM1);
000002  4802              LDR      r0,|L3.12|
000004  6841              LDR      r1,[r0,#4]  ; timer_callback
000006  4802              LDR      r0,|L3.16|
000008  4788              BLX      r1
;;;453    }
00000a  bd10              POP      {r4,pc}
;;;454    
                          ENDP

                  |L3.12|
                          DCD      timer_callback
                  |L3.16|
                          DCD      0x40010000

                          AREA ||i.TIM1_TRG_COM_TIM11_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_TRG_COM_TIM11_IRQHandler PROC
;;;605     */
;;;606    void TIM1_TRG_COM_TIM11_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;607    {
;;;608    	  timer_callback[TIM11_index](TIM11);
000002  4802              LDR      r0,|L4.12|
000004  6ac1              LDR      r1,[r0,#0x2c]  ; timer_callback
000006  4802              LDR      r0,|L4.16|
000008  4788              BLX      r1
;;;609    }
00000a  bd10              POP      {r4,pc}
;;;610    
                          ENDP

                  |L4.12|
                          DCD      timer_callback
                  |L4.16|
                          DCD      0x40014800

                          AREA ||i.TIM1_UP_TIM10_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM1_UP_TIM10_IRQHandler PROC
;;;595     */
;;;596    void TIM1_UP_TIM10_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;597    {
;;;598    	  timer_callback[TIM10_index](TIM10);
000002  4802              LDR      r0,|L5.12|
000004  6a81              LDR      r1,[r0,#0x28]  ; timer_callback
000006  4802              LDR      r0,|L5.16|
000008  4788              BLX      r1
;;;599    }
00000a  bd10              POP      {r4,pc}
;;;600    
                          ENDP

                  |L5.12|
                          DCD      timer_callback
                  |L5.16|
                          DCD      0x40014400

                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM2_IRQHandler PROC
;;;459     */
;;;460    void TIM2_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;461    {
;;;462    	  timer_callback[TIM2_index](TIM2);
000002  4803              LDR      r0,|L6.16|
000004  6881              LDR      r1,[r0,#8]  ; timer_callback
000006  f04f4080          MOV      r0,#0x40000000
00000a  4788              BLX      r1
;;;463    
;;;464    //// Update interrupt flag
;;;465    //// This bit is set by hardware on an update event. It is cleared by software.
;;;466    //	if((TIM2->SR)&TIM_SR_UIF){
;;;467    //	  timer_callback[TIM2_index](TIM2);
;;;468    //		TIM2->SR &= ~TIM_SR_UIF;		
;;;469    //		NVIC_ClearPendingIRQ(TIM2_IRQn);	
;;;470    //	}
;;;471    //// For TIMER CAPTURE
;;;472    ////	This flag is set by hardware only when the corresponding channel is configured in input 
;;;473    ////	capture mode. It is cleared by software by writing it to ‘0.
;;;474    ////	0: No overcapture has been detected
;;;475    ////	1: The counter value has been captured in TIMx_CCR1 register while CC1IF flag was 
;;;476    ////	already set
;;;477    //	if(TIM2->SR & TIM_SR_CC1OF){ // OverFlow
;;;478    //		timer_callback[TIM2_index](TIM2);
;;;479    ////		TIM2->SR &= ~TIM_SR_UIF;
;;;480    //		TIM2->SR &= ~TIM_SR_CC1OF;	
;;;481    //	}
;;;482    ////	If channel CC1 is configured as input:
;;;483    ////	This bit is set by hardware on a capture. It is cleared by software or by reading the 
;;;484    ////	TIMx_CCR1 register.
;;;485    //	if((TIM2->SR & TIM_SR_CC1IF) != 0){ 
;;;486    //		timer_callback[TIM2_index](TIM2);
;;;487    //		TIM2->SR &= ~TIM_SR_CC1IF;
;;;488    ////		TIM2->SR &= ~TIM_SR_CC1OF;	
;;;489    //	}
;;;490    //	TIM2->SR &= ~TIM_SR_UIF;
;;;491    
;;;492    }
00000c  bd10              POP      {r4,pc}
;;;493    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      timer_callback

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;498     */
;;;499    void TIM3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;500    {
;;;501    	  timer_callback[TIM3_index](TIM3);
000002  4802              LDR      r0,|L7.12|
000004  68c1              LDR      r1,[r0,#0xc]  ; timer_callback
000006  4802              LDR      r0,|L7.16|
000008  4788              BLX      r1
;;;502    
;;;503    //	if((TIM3->SR)&TIM_SR_UIF){
;;;504    //	  timer_callback[TIM3_index](TIM3);
;;;505    //		TIM3->SR &= ~TIM_SR_UIF;		
;;;506    //		NVIC_ClearPendingIRQ(TIM3_IRQn);	
;;;507    //	}
;;;508    }
00000a  bd10              POP      {r4,pc}
;;;509    
                          ENDP

                  |L7.12|
                          DCD      timer_callback
                  |L7.16|
                          DCD      0x40000400

                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;514     */
;;;515    void TIM4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;516    {
;;;517      timer_callback[TIM4_index](TIM4);
000002  4802              LDR      r0,|L8.12|
000004  6901              LDR      r1,[r0,#0x10]  ; timer_callback
000006  4802              LDR      r0,|L8.16|
000008  4788              BLX      r1
;;;518    
;;;519    //	if(TIM4->SR & TIM_SR_CC3IF){ // Capture occured
;;;520    //		TIM4->SR &= ~TIM_SR_CC3IF; // reset flag
;;;521    //	}
;;;522    
;;;523    //	if(TIM4->SR & TIM_SR_CC3OF){ // OverFlow Channelx
;;;524    //		TIM4->SR &= ~TIM_SR_CC3OF; // CCxIF automatically reset
;;;525    //	}
;;;526    
;;;527    //	if((TIM4->SR)&TIM_SR_UIF){ // OverFlow
;;;528    //		TIM4->SR &= ~TIM_SR_UIF;		
;;;529    //	}
;;;530    
;;;531    //	NVIC_ClearPendingIRQ(TIM4_IRQn);	
;;;532    
;;;533    }
00000a  bd10              POP      {r4,pc}
;;;534    
                          ENDP

                  |L8.12|
                          DCD      timer_callback
                  |L8.16|
                          DCD      0x40000800

                          AREA ||i.TIM5_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM5_IRQHandler PROC
;;;539     */
;;;540    void TIM5_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;541    {
;;;542    	  timer_callback[TIM5_index](TIM5);
000002  4802              LDR      r0,|L9.12|
000004  6941              LDR      r1,[r0,#0x14]  ; timer_callback
000006  4802              LDR      r0,|L9.16|
000008  4788              BLX      r1
;;;543    //	if((TIM5->SR)&TIM_SR_UIF){
;;;544    //	  timer_callback[TIM5_index](TIM5);
;;;545    //		TIM5->SR &= ~TIM_SR_UIF;		
;;;546    //		NVIC_ClearPendingIRQ(TIM5_IRQn);	
;;;547    //	}
;;;548    }
00000a  bd10              POP      {r4,pc}
;;;549    
                          ENDP

                  |L9.12|
                          DCD      timer_callback
                  |L9.16|
                          DCD      0x40000c00

                          AREA ||i.TIM6_DAC_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM6_DAC_IRQHandler PROC
;;;555     */
;;;556    void TIM6_DAC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;557    {
;;;558    	  timer_callback[TIM6_index](TIM6);
000002  4802              LDR      r0,|L10.12|
000004  6981              LDR      r1,[r0,#0x18]  ; timer_callback
000006  4802              LDR      r0,|L10.16|
000008  4788              BLX      r1
;;;559    }
00000a  bd10              POP      {r4,pc}
;;;560    
                          ENDP

                  |L10.12|
                          DCD      timer_callback
                  |L10.16|
                          DCD      0x40001000

                          AREA ||i.TIM7_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM7_IRQHandler PROC
;;;565     */
;;;566    void TIM7_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;567    {
;;;568    	  timer_callback[TIM7_index](TIM7);
000002  4802              LDR      r0,|L11.12|
000004  69c1              LDR      r1,[r0,#0x1c]  ; timer_callback
000006  4802              LDR      r0,|L11.16|
000008  4788              BLX      r1
;;;569    }
00000a  bd10              POP      {r4,pc}
;;;570    
                          ENDP

                  |L11.12|
                          DCD      timer_callback
                  |L11.16|
                          DCD      0x40001400

                          AREA ||i.TIM8_BRK_TIM12_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM8_BRK_TIM12_IRQHandler PROC
;;;615     */
;;;616    void TIM8_BRK_TIM12_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;617    {
;;;618    	  timer_callback[TIM12_index](TIM12);
000002  4802              LDR      r0,|L12.12|
000004  6b01              LDR      r1,[r0,#0x30]  ; timer_callback
000006  4802              LDR      r0,|L12.16|
000008  4788              BLX      r1
;;;619    }
00000a  bd10              POP      {r4,pc}
;;;620    
                          ENDP

                  |L12.12|
                          DCD      timer_callback
                  |L12.16|
                          DCD      0x40001800

                          AREA ||i.TIM8_CC_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM8_CC_IRQHandler PROC
;;;575     */
;;;576    void TIM8_CC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;577    {
;;;578    	  timer_callback[TIM8_index](TIM8);
000002  4802              LDR      r0,|L13.12|
000004  6a01              LDR      r1,[r0,#0x20]  ; timer_callback
000006  4802              LDR      r0,|L13.16|
000008  4788              BLX      r1
;;;579    }
00000a  bd10              POP      {r4,pc}
;;;580    
                          ENDP

                  |L13.12|
                          DCD      timer_callback
                  |L13.16|
                          DCD      0x40010400

                          AREA ||i.TIM8_TRG_COM_TIM14_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM8_TRG_COM_TIM14_IRQHandler PROC
;;;635     */
;;;636    void TIM8_TRG_COM_TIM14_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;637    {
;;;638    	  timer_callback[TIM14_index](TIM14);
000002  4802              LDR      r0,|L14.12|
000004  6b81              LDR      r1,[r0,#0x38]  ; timer_callback
000006  4802              LDR      r0,|L14.16|
000008  4788              BLX      r1
;;;639    }
00000a  bd10              POP      {r4,pc}
;;;640    
                          ENDP

                  |L14.12|
                          DCD      timer_callback
                  |L14.16|
                          DCD      0x40002000

                          AREA ||i.TIM8_UP_TIM13_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM8_UP_TIM13_IRQHandler PROC
;;;625     */
;;;626    void TIM8_UP_TIM13_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;627    {
;;;628    	  timer_callback[TIM13_index](TIM13);
000002  4802              LDR      r0,|L15.12|
000004  6b41              LDR      r1,[r0,#0x34]  ; timer_callback
000006  4802              LDR      r0,|L15.16|
000008  4788              BLX      r1
;;;629    }
00000a  bd10              POP      {r4,pc}
;;;630    
                          ENDP

                  |L15.12|
                          DCD      timer_callback
                  |L15.16|
                          DCD      0x40001c00

                          AREA ||i.TIMx_Capture_Config||, CODE, READONLY, ALIGN=1

                  TIMx_Capture_Config PROC
;;;280     */
;;;281    void TIMx_Capture_Config(TIM_TypeDef *TIMx, TimEdgeModeEnum Edge, TimChannelEnum ChannelSelect )
000000  2a01              CMP      r2,#1
;;;282    {
;;;283    	switch(ChannelSelect)
000002  d006              BEQ      |L16.18|
000004  2a02              CMP      r2,#2
000006  d028              BEQ      |L16.90|
000008  2a03              CMP      r2,#3
00000a  d04a              BEQ      |L16.162|
00000c  2a04              CMP      r2,#4
00000e  d17d              BNE      |L16.268|
000010  e06b              B        |L16.234|
                  |L16.18|
;;;284    	{
;;;285    		case TIM_CHANNEL_1:
;;;286    		// Setup capture settings for TIMx
;;;287    
;;;288    		// 00 = output
;;;289    		// 01 = input, CC1 is mapped on timer Input 1
;;;290    		// 10 = input, CC1 is mapped on timer Input 2
;;;291    		// 11 = input, CC1 is mapped on slave timer
;;;292    			TIMx->CCMR1 &= ~TIM_CCMR1_CC1S; // Reset default
000012  6983              LDR      r3,[r0,#0x18]
000014  f0230303          BIC      r3,r3,#3
000018  6183              STR      r3,[r0,#0x18]
;;;293    			TIMx->CCMR1 |= TIM_CCMR1_CC1S_0; // Channel : CAPTURE TI1
00001a  6983              LDR      r3,[r0,#0x18]
00001c  f0430301          ORR      r3,r3,#1
000020  6183              STR      r3,[r0,#0x18]
;;;294    
;;;295    		// Input Capture 1 Filter disabled
;;;296    		// because we want to capture every event
;;;297    			TIMx->CCMR1 &= ~TIM_CCMR1_IC1F;
000022  6983              LDR      r3,[r0,#0x18]
000024  f02303f0          BIC      r3,r3,#0xf0
000028  6183              STR      r3,[r0,#0x18]
;;;298    			//TIMx->CCMR1 |= TIM_CCMR1_IC1F_0 | TIM_CCMR1_IC1F_1;
;;;299    			
;;;300    		// Capture edge config
;;;301    			TIMx->CCER &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP); // reset first
00002a  6a03              LDR      r3,[r0,#0x20]
00002c  f023030a          BIC      r3,r3,#0xa
000030  6203              STR      r3,[r0,#0x20]
;;;302    			TIMx->CCER |= Edge << TIM_CCER_CC1P_Pos; // config edges
000032  6a03              LDR      r3,[r0,#0x20]
000034  ea430341          ORR      r3,r3,r1,LSL #1
000038  6203              STR      r3,[r0,#0x20]
;;;303    
;;;304    		// Program input prescaller
;;;305    		// To capture each valid transition, set input prescaler to zero (default)
;;;306    			TIMx->CCMR1 &= ~TIM_CCMR1_IC1PSC;
00003a  6983              LDR      r3,[r0,#0x18]
00003c  f023030c          BIC      r3,r3,#0xc
000040  6183              STR      r3,[r0,#0x18]
;;;307    
;;;308    		// Capture enable
;;;309    			TIMx->CCER |= TIM_CCER_CC1E; // Capture Enable
000042  6a03              LDR      r3,[r0,#0x20]
000044  f0430301          ORR      r3,r3,#1
000048  6203              STR      r3,[r0,#0x20]
;;;310    		// Capture interrupt enable	
;;;311    			TIMx->DIER |= TIM_DIER_CC1IE;
00004a  68c3              LDR      r3,[r0,#0xc]
00004c  f0430302          ORR      r3,r3,#2
000050  60c3              STR      r3,[r0,#0xc]
;;;312    
;;;313    		// Clear the Capture event flag for channel 1
;;;314    			TIMx->SR = ~TIM_SR_CC1IF;
000052  f06f0302          MVN      r3,#2
000056  6103              STR      r3,[r0,#0x10]
;;;315    		break;
000058  e06e              B        |L16.312|
                  |L16.90|
;;;316    		case TIM_CHANNEL_2:
;;;317    		// Setup input timer settings for TIMx
;;;318    			TIMx->CCMR1 &= ~TIM_CCMR1_CC2S; // Reset default
00005a  6983              LDR      r3,[r0,#0x18]
00005c  f4237340          BIC      r3,r3,#0x300
000060  6183              STR      r3,[r0,#0x18]
;;;319    			TIMx->CCMR1 |= TIM_CCMR1_CC2S_0; // Channel : CAPTURE TI1
000062  6983              LDR      r3,[r0,#0x18]
000064  f4437380          ORR      r3,r3,#0x100
000068  6183              STR      r3,[r0,#0x18]
;;;320    
;;;321    			TIMx->CCMR1 &= ~TIM_CCMR1_IC2F;
00006a  6983              LDR      r3,[r0,#0x18]
00006c  f4234370          BIC      r3,r3,#0xf000
000070  6183              STR      r3,[r0,#0x18]
;;;322    			//TIMx->CCMR1 |= TIM_CCMR1_IC2F_0 | TIM_CCMR1_IC2F_1;
;;;323    			
;;;324    			TIMx->CCER &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP); // reset
000072  6a03              LDR      r3,[r0,#0x20]
000074  f02303a0          BIC      r3,r3,#0xa0
000078  6203              STR      r3,[r0,#0x20]
;;;325    			TIMx->CCER |= Edge << TIM_CCER_CC2P_Pos; // config edges
00007a  6a03              LDR      r3,[r0,#0x20]
00007c  ea431341          ORR      r3,r3,r1,LSL #5
000080  6203              STR      r3,[r0,#0x20]
;;;326    
;;;327    			TIMx->CCMR1 &= ~TIM_CCMR1_IC2PSC;
000082  6983              LDR      r3,[r0,#0x18]
000084  f4236340          BIC      r3,r3,#0xc00
000088  6183              STR      r3,[r0,#0x18]
;;;328    
;;;329    			TIMx->CCER |= TIM_CCER_CC2E; // Capture Enable
00008a  6a03              LDR      r3,[r0,#0x20]
00008c  f0430310          ORR      r3,r3,#0x10
000090  6203              STR      r3,[r0,#0x20]
;;;330    			TIMx->DIER |= TIM_DIER_CC2IE;
000092  68c3              LDR      r3,[r0,#0xc]
000094  f0430304          ORR      r3,r3,#4
000098  60c3              STR      r3,[r0,#0xc]
;;;331    		// Clear the Capture event flag for channel 2
;;;332    			TIMx->SR = ~TIM_SR_CC2IF;
00009a  f06f0304          MVN      r3,#4
00009e  6103              STR      r3,[r0,#0x10]
;;;333    	
;;;334    		break;
0000a0  e04a              B        |L16.312|
                  |L16.162|
;;;335    		case TIM_CHANNEL_3:
;;;336    		// Setup input timer settings for TIMx
;;;337    			TIMx->CCMR2 &= ~TIM_CCMR2_CC3S; // Reset default
0000a2  69c3              LDR      r3,[r0,#0x1c]
0000a4  f0230303          BIC      r3,r3,#3
0000a8  61c3              STR      r3,[r0,#0x1c]
;;;338    			TIMx->CCMR2 |= TIM_CCMR2_CC3S_0; // Channel : CAPTURE TI1
0000aa  69c3              LDR      r3,[r0,#0x1c]
0000ac  f0430301          ORR      r3,r3,#1
0000b0  61c3              STR      r3,[r0,#0x1c]
;;;339    
;;;340    			TIMx->CCMR2 &= ~TIM_CCMR2_IC3F;
0000b2  69c3              LDR      r3,[r0,#0x1c]
0000b4  f02303f0          BIC      r3,r3,#0xf0
0000b8  61c3              STR      r3,[r0,#0x1c]
;;;341    			//TIMx->CCMR2 |= TIM_CCMR2_IC3F_0 | TIM_CCMR2_IC3F_1;
;;;342    			
;;;343    			TIMx->CCER &= ~(TIM_CCER_CC3P | TIM_CCER_CC3NP); // reset
0000ba  6a03              LDR      r3,[r0,#0x20]
0000bc  f4236320          BIC      r3,r3,#0xa00
0000c0  6203              STR      r3,[r0,#0x20]
;;;344    			TIMx->CCER |= Edge << TIM_CCER_CC3P_Pos; // config edges
0000c2  6a03              LDR      r3,[r0,#0x20]
0000c4  ea432341          ORR      r3,r3,r1,LSL #9
0000c8  6203              STR      r3,[r0,#0x20]
;;;345    
;;;346    			TIMx->CCMR2 &= ~TIM_CCMR2_IC3PSC;
0000ca  69c3              LDR      r3,[r0,#0x1c]
0000cc  f023030c          BIC      r3,r3,#0xc
0000d0  61c3              STR      r3,[r0,#0x1c]
;;;347    
;;;348    			TIMx->CCER |= TIM_CCER_CC3E; // Capture Enable
0000d2  6a03              LDR      r3,[r0,#0x20]
0000d4  f4437380          ORR      r3,r3,#0x100
0000d8  6203              STR      r3,[r0,#0x20]
;;;349    			TIMx->DIER |= TIM_DIER_CC3IE;
0000da  68c3              LDR      r3,[r0,#0xc]
0000dc  f0430308          ORR      r3,r3,#8
0000e0  60c3              STR      r3,[r0,#0xc]
;;;350    		// Clear the Capture event flag for channel 3
;;;351    			TIMx->SR = ~TIM_SR_CC3IF;
0000e2  f06f0308          MVN      r3,#8
0000e6  6103              STR      r3,[r0,#0x10]
;;;352    		
;;;353    			break;
0000e8  e026              B        |L16.312|
                  |L16.234|
;;;354    		case TIM_CHANNEL_4:
;;;355    		// Setup input timer settings for TIMx
;;;356    			TIMx->CCMR2 &= ~TIM_CCMR2_CC4S; // Reset default
0000ea  69c3              LDR      r3,[r0,#0x1c]
0000ec  f4237340          BIC      r3,r3,#0x300
0000f0  61c3              STR      r3,[r0,#0x1c]
;;;357    			TIMx->CCMR2 |= TIM_CCMR2_CC4S_0; // Channel : CAPTURE TI1
0000f2  69c3              LDR      r3,[r0,#0x1c]
0000f4  f4437380          ORR      r3,r3,#0x100
0000f8  61c3              STR      r3,[r0,#0x1c]
;;;358    
;;;359    			TIMx->CCMR2 &= ~TIM_CCMR2_IC4F;
0000fa  69c3              LDR      r3,[r0,#0x1c]
0000fc  f4234370          BIC      r3,r3,#0xf000
000100  61c3              STR      r3,[r0,#0x1c]
;;;360    			//TIMx->CCMR2 |= TIM_CCMR2_IC4F_0 | TIM_CCMR2_IC4F_1;
;;;361    			
;;;362    			TIMx->CCER &= ~(TIM_CCER_CC4P | TIM_CCER_CC4NP); // reset
000102  6a03              LDR      r3,[r0,#0x20]
000104  f4234320          BIC      r3,r3,#0xa000
000108  6203              STR      r3,[r0,#0x20]
;;;363    			TIMx->CCER |= Edge << TIM_CCER_CC4P_Pos; // config edges
00010a  e000              B        |L16.270|
                  |L16.268|
00010c  e013              B        |L16.310|
                  |L16.270|
00010e  6a03              LDR      r3,[r0,#0x20]
000110  ea433341          ORR      r3,r3,r1,LSL #13
000114  6203              STR      r3,[r0,#0x20]
;;;364    
;;;365    			TIMx->CCMR2 &= ~TIM_CCMR2_IC4PSC;
000116  69c3              LDR      r3,[r0,#0x1c]
000118  f4236340          BIC      r3,r3,#0xc00
00011c  61c3              STR      r3,[r0,#0x1c]
;;;366    
;;;367    			TIMx->CCER |= TIM_CCER_CC4E; // Capture Enable
00011e  6a03              LDR      r3,[r0,#0x20]
000120  f4435380          ORR      r3,r3,#0x1000
000124  6203              STR      r3,[r0,#0x20]
;;;368    			TIMx->DIER |= TIM_DIER_CC4IE;
000126  68c3              LDR      r3,[r0,#0xc]
000128  f0430310          ORR      r3,r3,#0x10
00012c  60c3              STR      r3,[r0,#0xc]
;;;369    		// Clear the Capture event flag for channel 4
;;;370    			TIMx->SR = ~TIM_SR_CC4IF;
00012e  f06f0310          MVN      r3,#0x10
000132  6103              STR      r3,[r0,#0x10]
;;;371    
;;;372    			break;
000134  e000              B        |L16.312|
                  |L16.310|
;;;373    		default:
;;;374    			// Not possible because enum needed
;;;375    			break;
000136  bf00              NOP      
                  |L16.312|
000138  bf00              NOP                            ;315
;;;376    	}
;;;377    // Re-initialize the counter and generates an update of the registers
;;;378    // LBR	TIMx->EGR |= TIM_EGR_UG;
;;;379    
;;;380    }
00013a  4770              BX       lr
;;;381    
                          ENDP


                          AREA ||i.TIMx_Counter_Disable||, CODE, READONLY, ALIGN=1

                  TIMx_Counter_Disable PROC
;;;397     */
;;;398    void TIMx_Counter_Disable(TIM_TypeDef *TIMx) {
000000  6801              LDR      r1,[r0,#0]
;;;399    	// Disable the timer.
;;;400    	TIMx->CR1 &= ~TIM_CR1_CEN;
000002  f0210101          BIC      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;401    	//SysTick->CTRL  &= ~SysTick_CTRL_ENABLE_Msk; 
;;;402    }
000008  4770              BX       lr
;;;403    
                          ENDP


                          AREA ||i.TIMx_Counter_Enable||, CODE, READONLY, ALIGN=1

                  TIMx_Counter_Enable PROC
;;;386     */
;;;387    void TIMx_Counter_Enable(TIM_TypeDef *TIMx) {
000000  6801              LDR      r1,[r0,#0]
;;;388    	// Enable the timer.
;;;389    	//SysTick_Config(timer_period);
;;;390    	TIMx->CR1 |= TIM_CR1_CEN;
000002  f0410101          ORR      r1,r1,#1
000006  6001              STR      r1,[r0,#0]
;;;391    }
000008  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.TIMx_Enable_Clock_Timer_||, CODE, READONLY, ALIGN=2

                  TIMx_Enable_Clock_Timer_ PROC
;;;430     */
;;;431    uint32_t TIMx_Enable_Clock_Timer_(TimClockTimerEnum ClockBusId) {
000000  4601              MOV      r1,r0
;;;432    		switch( ((ClockBusId&0xFF00) >>8) )
000002  0a08              LSRS     r0,r1,#8
000004  2801              CMP      r0,#1
000006  d002              BEQ      |L19.14|
000008  2802              CMP      r0,#2
00000a  d116              BNE      |L19.58|
00000c  e009              B        |L19.34|
                  |L19.14|
;;;433    		{
;;;434    			case 1:
;;;435    				RCC->APB1ENR |= ( 0x1U << (ClockBusId&0x0FF));
00000e  480c              LDR      r0,|L19.64|
000010  6800              LDR      r0,[r0,#0]
000012  2201              MOVS     r2,#1
000014  408a              LSLS     r2,r2,r1
000016  4310              ORRS     r0,r0,r2
000018  4a09              LDR      r2,|L19.64|
00001a  6010              STR      r0,[r2,#0]
;;;436    				return Apb1TimerClock;
00001c  4809              LDR      r0,|L19.68|
00001e  6800              LDR      r0,[r0,#0]  ; Apb1TimerClock
                  |L19.32|
;;;437    			case 2:
;;;438    				RCC->APB2ENR |= ( 0x1U << (ClockBusId&0x0FF));
;;;439    				return Apb2TimerClock;
;;;440    			default:
;;;441    				return 0;
;;;442    		}
;;;443    }
000020  4770              BX       lr
                  |L19.34|
000022  4807              LDR      r0,|L19.64|
000024  1d00              ADDS     r0,r0,#4              ;438
000026  6802              LDR      r2,[r0,#0]            ;438
000028  2001              MOVS     r0,#1                 ;438
00002a  4088              LSLS     r0,r0,r1              ;438
00002c  4302              ORRS     r2,r2,r0              ;438
00002e  4804              LDR      r0,|L19.64|
000030  1d00              ADDS     r0,r0,#4              ;438
000032  6002              STR      r2,[r0,#0]            ;438
000034  4804              LDR      r0,|L19.72|
000036  6800              LDR      r0,[r0,#0]            ;439  ; Apb2TimerClock
000038  e7f2              B        |L19.32|
                  |L19.58|
00003a  2000              MOVS     r0,#0                 ;441
00003c  e7f0              B        |L19.32|
;;;444    
                          ENDP

00003e  0000              DCW      0x0000
                  |L19.64|
                          DCD      0x40023840
                  |L19.68|
                          DCD      Apb1TimerClock
                  |L19.72|
                          DCD      Apb2TimerClock

                          AREA ||i.TIMx_PWM_Config||, CODE, READONLY, ALIGN=2

                  TIMx_PWM_Config PROC
;;;152     */
;;;153    void TIMx_PWM_Config(TIM_TypeDef *TIMx, TIM_PWM_Config PwmConfig )
000000  b507              PUSH     {r0-r2,lr}
;;;154    {
;;;155    	switch(PwmConfig.ChannelId)
000002  f89d1004          LDRB     r1,[sp,#4]
000006  f0010107          AND      r1,r1,#7
00000a  2901              CMP      r1,#1
00000c  d006              BEQ      |L20.28|
00000e  2902              CMP      r1,#2
000010  d02a              BEQ      |L20.104|
000012  2903              CMP      r1,#3
000014  d04f              BEQ      |L20.182|
000016  2904              CMP      r1,#4
000018  d174              BNE      |L20.260|
00001a  e074              B        |L20.262|
                  |L20.28|
;;;156    	{
;;;157    		case TIM_CHANNEL_1:
;;;158    // Output compare mode
;;;159    //	These bits define the behavior of the output reference signal OC1REF from which OC1 and 
;;;160    //	OC1N are derived
;;;161    			TIMx->CCMR1 &= ~TIM_CCMR1_OC1M_Msk;
00001c  6981              LDR      r1,[r0,#0x18]
00001e  f0210170          BIC      r1,r1,#0x70
000022  6181              STR      r1,[r0,#0x18]
;;;162    			TIMx->CCMR1 |= ( PwmConfig.OutputMode << TIM_CCMR1_OC1M_Pos);
000024  6981              LDR      r1,[r0,#0x18]
000026  f89d2004          LDRB     r2,[sp,#4]
00002a  f3c202c2          UBFX     r2,r2,#3,#3
00002e  ea411102          ORR      r1,r1,r2,LSL #4
000032  6181              STR      r1,[r0,#0x18]
;;;163    // Output Compare preload enable
;;;164    //	0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at anytime, the 
;;;165    //	new value is taken in account immediately.
;;;166    //	1: Preload register on TIMx_CCR1 enabled. Read/Write operations access the preload 
;;;167    //	register. TIMx_CCR1 preload value is loaded in the active register at each update event.
;;;168    		TIMx->CCMR1 &= ~TIM_CCMR1_OC1PE_Msk;
000034  6981              LDR      r1,[r0,#0x18]
000036  f0210108          BIC      r1,r1,#8
00003a  6181              STR      r1,[r0,#0x18]
;;;169    			TIMx->CCMR1 |= ( PwmConfig.Preload << TIM_CCMR1_OC1PE_Pos);
00003c  6981              LDR      r1,[r0,#0x18]
00003e  f89d2004          LDRB     r2,[sp,#4]
000042  f3c21280          UBFX     r2,r2,#6,#1
000046  ea4101c2          ORR      r1,r1,r2,LSL #3
00004a  6181              STR      r1,[r0,#0x18]
;;;170    //  capture/compare register 1
;;;171    // CCR1 is the value to be loaded in the actual capture/compare 1 register (preload value).
;;;172    // It is loaded permanently if the preload feature is not selected in the TIMx_CCMR1 register(bit OC1PE).
;;;173    // Else the preload value is copied in the active capture/compare 1 register when an update event occurs.
;;;174    // The active capture/compare register contains the value to be compared to the counter TIMx_CNT and signaled on OC1 output.
;;;175    //			TIMx->CCR1 	 = ((float)PwmConfig.DutyCycle /100) * TIMx->ARR;                                 // Output Compare Register for channel 1
;;;176    			TIMx->CCR1 	 = PwmConfig.CompareValue-1;                                 // Output Compare Register for channel 1
00004c  9902              LDR      r1,[sp,#8]
00004e  1e49              SUBS     r1,r1,#1
000050  6341              STR      r1,[r0,#0x34]
;;;177    // Bit 0  CC1E: Compare 1 output enable
;;;178    // 0: Off - OC1 is not active. OC1 level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
;;;179    // 1: On - OC1 signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1NE bits.
;;;180    			TIMx->CCER 	 	&= ~TIM_CCER_CC1E_Msk;                       // Enable output for ch1
000052  6a01              LDR      r1,[r0,#0x20]
000054  f0210101          BIC      r1,r1,#1
000058  6201              STR      r1,[r0,#0x20]
;;;181    			TIMx->CCER 	 	|= (PwmConfig.OutputEnable << TIM_CCER_CC1E_Pos );          // Enable output for ch1
00005a  6a01              LDR      r1,[r0,#0x20]
00005c  f89d2004          LDRB     r2,[sp,#4]
000060  ea4111d2          ORR      r1,r1,r2,LSR #7
000064  6201              STR      r1,[r0,#0x20]
;;;182    
;;;183    		break;
000066  e076              B        |L20.342|
                  |L20.104|
;;;184    		case TIM_CHANNEL_2:
;;;185    			// Output compare mode
;;;186    			TIMx->CCMR1 &= ~TIM_CCMR1_OC2M_Msk;
000068  6981              LDR      r1,[r0,#0x18]
00006a  f42141e0          BIC      r1,r1,#0x7000
00006e  6181              STR      r1,[r0,#0x18]
;;;187    			TIMx->CCMR1 |= ( PwmConfig.OutputMode << TIM_CCMR1_OC2M_Pos);
000070  6981              LDR      r1,[r0,#0x18]
000072  f89d2004          LDRB     r2,[sp,#4]
000076  f3c202c2          UBFX     r2,r2,#3,#3
00007a  ea413102          ORR      r1,r1,r2,LSL #12
00007e  6181              STR      r1,[r0,#0x18]
;;;188    			// Output Compare preload enable
;;;189    			TIMx->CCMR1 &= ~TIM_CCMR1_OC2PE_Msk;
000080  6981              LDR      r1,[r0,#0x18]
000082  f4216100          BIC      r1,r1,#0x800
000086  6181              STR      r1,[r0,#0x18]
;;;190    			TIMx->CCMR1 |= ( PwmConfig.Preload << TIM_CCMR1_OC2PE_Pos);
000088  6981              LDR      r1,[r0,#0x18]
00008a  f89d2004          LDRB     r2,[sp,#4]
00008e  f3c21280          UBFX     r2,r2,#6,#1
000092  ea4121c2          ORR      r1,r1,r2,LSL #11
000096  6181              STR      r1,[r0,#0x18]
;;;191    			TIMx->CCR2 	 = PwmConfig.CompareValue-1;                                 // Output Compare Register for channel 2
000098  9902              LDR      r1,[sp,#8]
00009a  1e49              SUBS     r1,r1,#1
00009c  6381              STR      r1,[r0,#0x38]
;;;192    // Bit 0  CC1E: Compare 1 output enable
;;;193    			TIMx->CCER 	 	&= ~TIM_CCER_CC2E_Msk;                       // Enable output for ch1
00009e  6a01              LDR      r1,[r0,#0x20]
0000a0  f0210110          BIC      r1,r1,#0x10
0000a4  6201              STR      r1,[r0,#0x20]
;;;194    			TIMx->CCER 	 	|= (PwmConfig.OutputEnable << TIM_CCER_CC2E_Pos );          // Enable output for ch1
0000a6  6a01              LDR      r1,[r0,#0x20]
0000a8  f89d2004          LDRB     r2,[sp,#4]
0000ac  09d2              LSRS     r2,r2,#7
0000ae  ea411102          ORR      r1,r1,r2,LSL #4
0000b2  6201              STR      r1,[r0,#0x20]
;;;195    			break;
0000b4  e04f              B        |L20.342|
                  |L20.182|
;;;196    		case TIM_CHANNEL_3:
;;;197    			// Output compare mode
;;;198    			TIMx->CCMR2 &= ~TIM_CCMR2_OC3M_Msk;
0000b6  69c1              LDR      r1,[r0,#0x1c]
0000b8  f0210170          BIC      r1,r1,#0x70
0000bc  61c1              STR      r1,[r0,#0x1c]
;;;199    			TIMx->CCMR2 |= ( PwmConfig.OutputMode << TIM_CCMR2_OC3M_Pos);
0000be  69c1              LDR      r1,[r0,#0x1c]
0000c0  f89d2004          LDRB     r2,[sp,#4]
0000c4  f3c202c2          UBFX     r2,r2,#3,#3
0000c8  ea411102          ORR      r1,r1,r2,LSL #4
0000cc  61c1              STR      r1,[r0,#0x1c]
;;;200    			// Output Compare preload enable
;;;201    			TIMx->CCMR2 &= ~TIM_CCMR1_OC1PE_Msk;
0000ce  69c1              LDR      r1,[r0,#0x1c]
0000d0  f0210108          BIC      r1,r1,#8
0000d4  61c1              STR      r1,[r0,#0x1c]
;;;202    			TIMx->CCMR2 |= ( PwmConfig.Preload << TIM_CCMR2_OC3PE_Pos);
0000d6  69c1              LDR      r1,[r0,#0x1c]
0000d8  f89d2004          LDRB     r2,[sp,#4]
0000dc  f3c21280          UBFX     r2,r2,#6,#1
0000e0  ea4101c2          ORR      r1,r1,r2,LSL #3
0000e4  61c1              STR      r1,[r0,#0x1c]
;;;203    			TIMx->CCR3 	 = PwmConfig.CompareValue-1;                                 // Output Compare Register for channel 3
0000e6  9902              LDR      r1,[sp,#8]
0000e8  1e49              SUBS     r1,r1,#1
0000ea  63c1              STR      r1,[r0,#0x3c]
;;;204    // Bit 0  CC1E: Compare 1 output enable
;;;205    			TIMx->CCER 	 	&= ~TIM_CCER_CC3E_Msk;                       // Enable output for ch1
0000ec  6a01              LDR      r1,[r0,#0x20]
0000ee  f4217180          BIC      r1,r1,#0x100
0000f2  6201              STR      r1,[r0,#0x20]
;;;206    			TIMx->CCER 	 	|= (PwmConfig.OutputEnable << TIM_CCER_CC3E_Pos );          // Enable output for ch1
0000f4  6a01              LDR      r1,[r0,#0x20]
0000f6  f89d2004          LDRB     r2,[sp,#4]
0000fa  09d2              LSRS     r2,r2,#7
0000fc  ea412102          ORR      r1,r1,r2,LSL #8
000100  6201              STR      r1,[r0,#0x20]
;;;207    			break;
000102  e028              B        |L20.342|
                  |L20.260|
000104  e026              B        |L20.340|
                  |L20.262|
;;;208    		case TIM_CHANNEL_4:
;;;209    			// Output compare mode
;;;210    			TIMx->CCMR2 &= ~TIM_CCMR2_OC4M_Msk;
000106  69c1              LDR      r1,[r0,#0x1c]
000108  f42141e0          BIC      r1,r1,#0x7000
00010c  61c1              STR      r1,[r0,#0x1c]
;;;211    			TIMx->CCMR2 |= ( PwmConfig.OutputMode << TIM_CCMR2_OC4M_Pos);
00010e  69c1              LDR      r1,[r0,#0x1c]
000110  f89d2004          LDRB     r2,[sp,#4]
000114  f3c202c2          UBFX     r2,r2,#3,#3
000118  ea413102          ORR      r1,r1,r2,LSL #12
00011c  61c1              STR      r1,[r0,#0x1c]
;;;212    			// Output Compare preload enable
;;;213    			TIMx->CCMR2 &= ~TIM_CCMR1_OC1PE_Msk;
00011e  69c1              LDR      r1,[r0,#0x1c]
000120  f0210108          BIC      r1,r1,#8
000124  61c1              STR      r1,[r0,#0x1c]
;;;214    			TIMx->CCMR2 |= ( PwmConfig.Preload << TIM_CCMR2_OC4PE_Pos);
000126  69c1              LDR      r1,[r0,#0x1c]
000128  f89d2004          LDRB     r2,[sp,#4]
00012c  f3c21280          UBFX     r2,r2,#6,#1
000130  ea4121c2          ORR      r1,r1,r2,LSL #11
000134  61c1              STR      r1,[r0,#0x1c]
;;;215    			TIMx->CCR4 	 = PwmConfig.CompareValue-1;                                 // Output Compare Register for channel 4
000136  9902              LDR      r1,[sp,#8]
000138  1e49              SUBS     r1,r1,#1
00013a  6401              STR      r1,[r0,#0x40]
;;;216    // Bit 0  CC1E: Compare 1 output enable
;;;217    			TIMx->CCER 	 	&= ~TIM_CCER_CC4E_Msk;                       // Enable output for ch1
00013c  6a01              LDR      r1,[r0,#0x20]
00013e  f4215180          BIC      r1,r1,#0x1000
000142  6201              STR      r1,[r0,#0x20]
;;;218    			TIMx->CCER 	 	|= (PwmConfig.OutputEnable << TIM_CCER_CC4E_Pos );          // Enable output for ch1
000144  6a01              LDR      r1,[r0,#0x20]
000146  f89d2004          LDRB     r2,[sp,#4]
00014a  09d2              LSRS     r2,r2,#7
00014c  ea413102          ORR      r1,r1,r2,LSL #12
000150  6201              STR      r1,[r0,#0x20]
;;;219    			break;
000152  e000              B        |L20.342|
                  |L20.340|
;;;220    		default:
;;;221    			// Not possible because enum needed
;;;222    			break;
000154  bf00              NOP      
                  |L20.342|
000156  bf00              NOP                            ;183
;;;223    	}
;;;224    
;;;225    	//TIMx->CR1 	 		|= TIM_CR1_ARPE;                        // Auto-reload preload enable
;;;226    
;;;227    // Advanced-control timers
;;;228      if((TIMx == TIM1) || (TIMx == TIM8) ) 
000158  4907              LDR      r1,|L20.376|
00015a  4288              CMP      r0,r1
00015c  d002              BEQ      |L20.356|
00015e  4907              LDR      r1,|L20.380|
000160  4288              CMP      r0,r1
000162  d108              BNE      |L20.374|
                  |L20.356|
;;;229      {
;;;230    // MOE: Main output enable
;;;231    // This bit is cleared asynchronously by hardware as soon as the break input is active. It is set by software
;;;232    // or automatically depending on the AOE bit. It is acting only on the channels which are configured in output.
;;;233    // 0: OC and OCN outputs are disabled or forced to idle state.
;;;234    // 1: OC and OCN outputs are enabled if their respective enable bits are set (CCxE, CCxNE in TIMx_CCER register).
;;;235    			TIMx->BDTR |= TIM_BDTR_MOE;  
000164  6c41              LDR      r1,[r0,#0x44]
000166  f4414100          ORR      r1,r1,#0x8000
00016a  6441              STR      r1,[r0,#0x44]
;;;236    		
;;;237    // CC1NE: Capture/Compare 1 complementary output enable
;;;238    // 0: Off - OC1N is not active. OC1N level is then function of MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.
;;;239    // 1: On - OC1N signal is output on the corresponding output pin depending on MOE, OSSI, OSSR, OIS1, OIS1N and CC1E bits.		
;;;240    		TIMx->CCER |= (TIM_CCER_CC1NE | TIM_CCER_CC2NE | TIM_CCER_CC3NE); 
00016c  6a01              LDR      r1,[r0,#0x20]
00016e  f2404244          MOV      r2,#0x444
000172  4311              ORRS     r1,r1,r2
000174  6201              STR      r1,[r0,#0x20]
                  |L20.374|
;;;241    	}
;;;242    }
000176  bd0e              POP      {r1-r3,pc}
;;;243    
                          ENDP

                  |L20.376|
                          DCD      0x40010000
                  |L20.380|
                          DCD      0x40010400

                          AREA ||i.TIMx_PWM_UpdateDutyCycle||, CODE, READONLY, ALIGN=2

                  TIMx_PWM_UpdateDutyCycle PROC
;;;251     */
;;;252    void TIMx_PWM_UpdateDutyCycle(TIM_TypeDef *TIMx, TimChannelEnum ChannelId, uint8_t DutyCycle  )
000000  2901              CMP      r1,#1
;;;253    {
;;;254    	switch(ChannelId)
000002  d006              BEQ      |L21.18|
000004  2902              CMP      r1,#2
000006  d019              BEQ      |L21.60|
000008  2903              CMP      r1,#3
00000a  d02c              BEQ      |L21.102|
00000c  2904              CMP      r1,#4
00000e  d154              BNE      |L21.186|
000010  e03e              B        |L21.144|
                  |L21.18|
;;;255    	{
;;;256    		case TIM_CHANNEL_1:
;;;257    			TIMx->CCR1 	 = ((float)DutyCycle /100) * TIMx->ARR;                                 // Output Compare Register for channel 1
000012  ee002a10          VMOV     s0,r2
000016  eeb80a40          VCVT.F32.U32 s0,s0
00001a  ed9f1a29          VLDR     s2,|L21.192|
00001e  eec00a01          VDIV.F32 s1,s0,s2
000022  6ac3              LDR      r3,[r0,#0x2c]
000024  ee003a10          VMOV     s0,r3
000028  eeb80a40          VCVT.F32.U32 s0,s0
00002c  ee200a80          VMUL.F32 s0,s1,s0
000030  eebc0ac0          VCVT.U32.F32 s0,s0
000034  ee103a10          VMOV     r3,s0
000038  6343              STR      r3,[r0,#0x34]
;;;258    		break;
00003a  e03f              B        |L21.188|
                  |L21.60|
;;;259    		case TIM_CHANNEL_2:
;;;260    			TIMx->CCR2 	 = ((float)DutyCycle /100) * TIMx->ARR;                                 // Output Compare Register for channel 2
00003c  ee002a10          VMOV     s0,r2
000040  eeb80a40          VCVT.F32.U32 s0,s0
000044  ed9f1a1e          VLDR     s2,|L21.192|
000048  eec00a01          VDIV.F32 s1,s0,s2
00004c  6ac3              LDR      r3,[r0,#0x2c]
00004e  ee003a10          VMOV     s0,r3
000052  eeb80a40          VCVT.F32.U32 s0,s0
000056  ee200a80          VMUL.F32 s0,s1,s0
00005a  eebc0ac0          VCVT.U32.F32 s0,s0
00005e  ee103a10          VMOV     r3,s0
000062  6383              STR      r3,[r0,#0x38]
;;;261    			break;
000064  e02a              B        |L21.188|
                  |L21.102|
;;;262    		case TIM_CHANNEL_3:
;;;263    			TIMx->CCR3 	 = ((float)DutyCycle /100) * TIMx->ARR;                                 // Output Compare Register for channel 3
000066  ee002a10          VMOV     s0,r2
00006a  eeb80a40          VCVT.F32.U32 s0,s0
00006e  ed9f1a14          VLDR     s2,|L21.192|
000072  eec00a01          VDIV.F32 s1,s0,s2
000076  6ac3              LDR      r3,[r0,#0x2c]
000078  ee003a10          VMOV     s0,r3
00007c  eeb80a40          VCVT.F32.U32 s0,s0
000080  ee200a80          VMUL.F32 s0,s1,s0
000084  eebc0ac0          VCVT.U32.F32 s0,s0
000088  ee103a10          VMOV     r3,s0
00008c  63c3              STR      r3,[r0,#0x3c]
;;;264    			break;
00008e  e015              B        |L21.188|
                  |L21.144|
;;;265    		case TIM_CHANNEL_4:
;;;266    			TIMx->CCR4 	 = ((float)DutyCycle /100) * TIMx->ARR;                                 // Output Compare Register for channel 4
000090  ee002a10          VMOV     s0,r2
000094  eeb80a40          VCVT.F32.U32 s0,s0
000098  ed9f1a09          VLDR     s2,|L21.192|
00009c  eec00a01          VDIV.F32 s1,s0,s2
0000a0  6ac3              LDR      r3,[r0,#0x2c]
0000a2  ee003a10          VMOV     s0,r3
0000a6  eeb80a40          VCVT.F32.U32 s0,s0
0000aa  ee200a80          VMUL.F32 s0,s1,s0
0000ae  eebc0ac0          VCVT.U32.F32 s0,s0
0000b2  ee103a10          VMOV     r3,s0
0000b6  6403              STR      r3,[r0,#0x40]
;;;267    			break;
0000b8  e000              B        |L21.188|
                  |L21.186|
;;;268    		default:
;;;269    			// Not possible because enum needed
;;;270    			break;
0000ba  bf00              NOP      
                  |L21.188|
0000bc  bf00              NOP                            ;258
;;;271    	}
;;;272    }
0000be  4770              BX       lr
;;;273    
                          ENDP

                  |L21.192|
0000c0  42c80000          DCFS     0x42c80000 ; 100

                          AREA ||i.timer_Init_||, CODE, READONLY, ALIGN=2

                  timer_Init_ PROC
;;;85      */
;;;86      void timer_Init_( TIM_TypeDef *TIMx, TimClockTimerEnum ClockBusId, TIM_Base_InitTypeDef* TIMxInitValue )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;87     {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;88     	uint32_t TimInputClock = TIMx_Enable_Clock_Timer_(ClockBusId);
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       TIMx_Enable_Clock_Timer_
000010  4607              MOV      r7,r0
;;;89     	
;;;90     // SystemClock as Input by default
;;;91     	
;;;92     	/* Select the Counter Mode */
;;;93     	TIMx->CR1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
000012  6820              LDR      r0,[r4,#0]
000014  f0200070          BIC      r0,r0,#0x70
000018  6020              STR      r0,[r4,#0]
;;;94     	TIMx->CR1 |= (TIMxInitValue->CounterDir << TIM_CR1_DIR_Pos) | (TIMxInitValue->CounterMode << TIM_CR1_CMS_Pos) ;
00001a  7968              LDRB     r0,[r5,#5]
00001c  0100              LSLS     r0,r0,#4
00001e  7929              LDRB     r1,[r5,#4]
000020  ea401041          ORR      r0,r0,r1,LSL #5
000024  6821              LDR      r1,[r4,#0]
000026  4308              ORRS     r0,r0,r1
000028  6020              STR      r0,[r4,#0]
;;;95     	/* Set the clock division */
;;;96     #if defined(TIM6) || defined(TIM7)
;;;97       if((TIMx != TIM6) && (TIMx != TIM7))
00002a  4822              LDR      r0,|L22.180|
00002c  4284              CMP      r4,r0
00002e  d008              BEQ      |L22.66|
000030  4821              LDR      r0,|L22.184|
000032  4284              CMP      r4,r0
000034  d005              BEQ      |L22.66|
;;;98       {
;;;99         /* Set the clock division */
;;;100        TIMx->CR1 &=  ~TIM_CR1_CKD;
000036  6820              LDR      r0,[r4,#0]
000038  f4207040          BIC      r0,r0,#0x300
00003c  6020              STR      r0,[r4,#0]
;;;101        TIMx->CR1 |= TIM_CKD_DIV1;
00003e  6820              LDR      r0,[r4,#0]
000040  6020              STR      r0,[r4,#0]
                  |L22.66|
;;;102      }
;;;103    #endif
;;;104    	
;;;105      /* Set the Prescaler value */
;;;106    	if( (TimInputClock/TIMxInitValue->InputClk_Counter) > 65535) // PSC can't be more than 0xFFFF
000042  6828              LDR      r0,[r5,#0]
000044  fbb7f0f0          UDIV     r0,r7,r0
000048  f5b03f80          CMP      r0,#0x10000
00004c  d303              BCC      |L22.86|
;;;107    		assert_failed(__FILE__,__LINE__);
00004e  216b              MOVS     r1,#0x6b
000050  a01a              ADR      r0,|L22.188|
000052  f7fffffe          BL       assert_failed
                  |L22.86|
;;;108    	TIMx->PSC = TimInputClock/TIMxInitValue->InputClk_Counter-1;
000056  6828              LDR      r0,[r5,#0]
000058  fbb7f0f0          UDIV     r0,r7,r0
00005c  1e40              SUBS     r0,r0,#1
00005e  62a0              STR      r0,[r4,#0x28]
;;;109    
;;;110      /* Set the Auto-reload value */
;;;111    	TIMx->ARR = TIMxInitValue->Period;
000060  68a8              LDR      r0,[r5,#8]
000062  62e0              STR      r0,[r4,#0x2c]
;;;112    	
;;;113    	if( TIM_InitValue.CounterConfig & DIER_UIE)
000064  4818              LDR      r0,|L22.200|
000066  7b00              LDRB     r0,[r0,#0xc]  ; TIM_InitValue
000068  f0000001          AND      r0,r0,#1
00006c  b118              CBZ      r0,|L22.118|
;;;114    		TIMx->DIER |= TIM_DIER_UIE;   											// Enable interrupt on update event or CNT reset
00006e  68e0              LDR      r0,[r4,#0xc]
000070  f0400001          ORR      r0,r0,#1
000074  60e0              STR      r0,[r4,#0xc]
                  |L22.118|
;;;115    
;;;116      /* Generate an update event to reload the Prescaler */
;;;117    // LBR	TIMx->EGR |= TIM_EGR_UG;  // or TIM_PSCReloadMode_Immediate
;;;118    
;;;119    	if( (TIM_InitValue.CounterConfig) & RESET_COUNTER_ON_TRIG) // Specific feature to reset CNT when capture occured
000076  4814              LDR      r0,|L22.200|
000078  7b00              LDRB     r0,[r0,#0xc]  ; TIM_InitValue
00007a  f0000002          AND      r0,r0,#2
00007e  b178              CBZ      r0,|L22.160|
;;;120    	{
;;;121    	// To reset Counter when capture occurs, set in SMCR with trig:
;;;122    	//  TS: Trigger selection to 
;;;123    	//	101: Filtered Timer Input 1 (TI1FP1) or 
;;;124    	//	110: Filtered Timer Input 2 (TI2FP2)
;;;125    		TIMx->SMCR &= ~TIM_SMCR_TS_Msk;
000080  68a0              LDR      r0,[r4,#8]
000082  f0200070          BIC      r0,r0,#0x70
000086  60a0              STR      r0,[r4,#8]
;;;126    	//	TIMx->SMCR |= (TIM_SMCR_TS_2 | TIM_SMCR_TS_0); // For TI1FP1 : 101
;;;127    		TIMx->SMCR |= (TIM_SMCR_TS_2 | TIM_SMCR_TS_1); // For TI2FP2 : 110
000088  68a0              LDR      r0,[r4,#8]
00008a  f0400060          ORR      r0,r0,#0x60
00008e  60a0              STR      r0,[r4,#8]
;;;128    	//	SMS: Slave mode selection to
;;;129    	//	100: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes
;;;130    	//	                  the counter and generates an update of the registers.
;;;131    		TIMx->SMCR &= ~TIM_SMCR_SMS_Msk;
000090  68a0              LDR      r0,[r4,#8]
000092  f0200007          BIC      r0,r0,#7
000096  60a0              STR      r0,[r4,#8]
;;;132    	// LBR Pb when PWM & Capture on same Timer	
;;;133    		TIMx->SMCR |= TIM_SMCR_SMS_2; // 100
000098  68a0              LDR      r0,[r4,#8]
00009a  f0400004          ORR      r0,r0,#4
00009e  60a0              STR      r0,[r4,#8]
                  |L22.160|
;;;134    	}
;;;135    	
;;;136    	// Advanced-control timers
;;;137      if((TIMx == TIM1) || (TIMx == TIM8) ) 
0000a0  480a              LDR      r0,|L22.204|
0000a2  4284              CMP      r4,r0
0000a4  d002              BEQ      |L22.172|
0000a6  480a              LDR      r0,|L22.208|
0000a8  4284              CMP      r4,r0
0000aa  d101              BNE      |L22.176|
                  |L22.172|
;;;138      {
;;;139        /* Set the Repetition Counter value (only for TIM1 and TIM8) */
;;;140        TIMx->RCR = 0;
0000ac  2000              MOVS     r0,#0
0000ae  6320              STR      r0,[r4,#0x30]
                  |L22.176|
;;;141    	}
;;;142    		
;;;143    // Only counter overflow/underflow generates an update interrupt
;;;144    // LBR no needed ?	TIMx->CR1 |= TIM_CR1_URS;
;;;145    }
0000b0  e8bd81f0          POP      {r4-r8,pc}
;;;146    
                          ENDP

                  |L22.180|
                          DCD      0x40001000
                  |L22.184|
                          DCD      0x40001400
                  |L22.188|
0000bc  5372635c          DCB      "Src\\timer.c",0
0000c0  74696d65
0000c4  722e6300
                  |L22.200|
                          DCD      TIM_InitValue
                  |L22.204|
                          DCD      0x40010000
                  |L22.208|
                          DCD      0x40010400

                          AREA ||i.timer_set_callback_||, CODE, READONLY, ALIGN=2

                  timer_set_callback_ PROC
;;;412     */
;;;413    void timer_set_callback_(TIM_TypeDef *TIMx, int TIMx_IRQn, TimCallBackFuncIndexEnum TIMx_index,void (*callback)( TIM_TypeDef * ) ) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4604              MOV      r4,r0
000004  4615              MOV      r5,r2
;;;414    		
;;;415    	timer_callback[TIMx_index] = callback;
000006  481c              LDR      r0,|L23.120|
000008  f8403025          STR      r3,[r0,r5,LSL #2]
;;;416    
;;;417    	TIMx->SR &= ~TIM_SR_UIF;
00000c  6920              LDR      r0,[r4,#0x10]
00000e  f0200001          BIC      r0,r0,#1
000012  6120              STR      r0,[r4,#0x10]
;;;418    	
;;;419    	NVIC_SetPriority( (IRQn_Type)TIMx_IRQn,3);
000014  b248              SXTB     r0,r1
000016  2203              MOVS     r2,#3
000018  2800              CMP      r0,#0
00001a  db04              BLT      |L23.38|
00001c  0716              LSLS     r6,r2,#28
00001e  0e37              LSRS     r7,r6,#24
000020  4e16              LDR      r6,|L23.124|
000022  5437              STRB     r7,[r6,r0]
000024  e008              B        |L23.56|
                  |L23.38|
000026  0716              LSLS     r6,r2,#28
000028  ea4f6c16          LSR      r12,r6,#24
00002c  4e14              LDR      r6,|L23.128|
00002e  f000070f          AND      r7,r0,#0xf
000032  1f3f              SUBS     r7,r7,#4
000034  f806c007          STRB     r12,[r6,r7]
                  |L23.56|
000038  bf00              NOP      
;;;420    	NVIC_ClearPendingIRQ( (IRQn_Type)TIMx_IRQn);
00003a  b248              SXTB     r0,r1
00003c  2800              CMP      r0,#0
00003e  db07              BLT      |L23.80|
000040  f000061f          AND      r6,r0,#0x1f
000044  2201              MOVS     r2,#1
000046  40b2              LSLS     r2,r2,r6
000048  4e0e              LDR      r6,|L23.132|
00004a  0947              LSRS     r7,r0,#5
00004c  f8462027          STR      r2,[r6,r7,LSL #2]
                  |L23.80|
000050  bf00              NOP      
;;;421    	NVIC_EnableIRQ( (IRQn_Type)TIMx_IRQn);
000052  b248              SXTB     r0,r1
000054  2800              CMP      r0,#0
000056  db0d              BLT      |L23.116|
000058  bf00              NOP      
00005a  bf00              NOP      
00005c  f000061f          AND      r6,r0,#0x1f
000060  2201              MOVS     r2,#1
000062  40b2              LSLS     r2,r2,r6
000064  0946              LSRS     r6,r0,#5
000066  00b6              LSLS     r6,r6,#2
000068  f10626e0          ADD      r6,r6,#0xe000e000
00006c  f8c62100          STR      r2,[r6,#0x100]
000070  bf00              NOP      
000072  bf00              NOP      
                  |L23.116|
000074  bf00              NOP      
;;;422    
;;;423    }
000076  bdf0              POP      {r4-r7,pc}
;;;424    
                          ENDP

                  |L23.120|
                          DCD      timer_callback
                  |L23.124|
                          DCD      0xe000e400
                  |L23.128|
                          DCD      0xe000ed18
                  |L23.132|
                          DCD      0xe000e280

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  TIM_InitValue
                          %        16

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  IrqNumber
000000  001b1c1d          DCB      0x00,0x1b,0x1c,0x1d
000004  1e323637          DCB      0x1e,0x32,0x36,0x37
000008  2e18191a          DCB      0x2e,0x18,0x19,0x1a
00000c  2b2c2d            DCB      0x2b,0x2c,0x2d

                          AREA ||.data||, DATA, ALIGN=2

                  timer_callback
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc
                          DCD      DefaultFunc

;*** Start embedded assembler ***

#line 1 "Src\\timer.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_10ac5741____REV16|
#line 492 "D:\\Users\\Laurent\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___7_timer_c_10ac5741____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_10ac5741____REVSH|
#line 507
|__asm___7_timer_c_10ac5741____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___7_timer_c_10ac5741____RRX|
#line 694
|__asm___7_timer_c_10ac5741____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
