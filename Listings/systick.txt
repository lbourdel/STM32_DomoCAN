; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\systick.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\systick.d --cpu=Cortex-M4.fp.sp --apcs=interwork -O0 -Otime --diag_suppress=9931 -I.\Inc -I.\System_Files -I.\RTE\_NucleoF446xx -ID:\Users\Laurent\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -ID:\Users\Laurent\AppData\Local\Arm\Packs\Keil\STM32F4xx_DFP\2.14.0\Drivers\CMSIS\Device\ST\STM32F4xx\Include -D__UVISION_VERSION=529 -D_RTE_ -DSTM32F446xx -D_DEBUG -DUSE_HAL_CAN_REGISTER_CALLBACKS --omf_browse=.\objects\systick.crf Src\SysTick.c]
                          THUMB

                          AREA ||i.Delay_ms||, CODE, READONLY, ALIGN=2

                  Delay_ms PROC
;;;50      */
;;;51     void Delay_ms(uint32_t nTime) {
000000  4903              LDR      r1,|L1.16|
;;;52       // nTime: specifies the delay time length
;;;53       SysTickTimeDelay = nTime;      // SysTickTimeDelay must be declared as volatile
000002  6008              STR      r0,[r1,#0]  ; SysTickTimeDelay
;;;54       while(SysTickTimeDelay != 0);  // Busy wait
000004  bf00              NOP      
                  |L1.6|
000006  4902              LDR      r1,|L1.16|
000008  6809              LDR      r1,[r1,#0]  ; SysTickTimeDelay
00000a  2900              CMP      r1,#0
00000c  d1fb              BNE      |L1.6|
;;;55     }
00000e  4770              BX       lr
;;;56     
                          ENDP

                  |L1.16|
                          DCD      SysTickTimeDelay

                          AREA ||i.SysTick_GetTick||, CODE, READONLY, ALIGN=2

                  SysTick_GetTick PROC
;;;72      */
;;;73     uint32_t SysTick_GetTick (void) {
000000  4801              LDR      r0,|L2.8|
;;;74     	return SysTickCurrenTick;
000002  6800              LDR      r0,[r0,#0]  ; SysTickCurrenTick
;;;75     }
000004  4770              BX       lr
                          ENDP

000006  0000              DCW      0x0000
                  |L2.8|
                          DCD      SysTickCurrenTick

                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;61      */
;;;62     void SysTick_Handler (void) { // SysTick interrupt service routine 
000000  4806              LDR      r0,|L3.28|
;;;63       if (SysTickTimeDelay > 0)    // Prevent it from being negative 
000002  6800              LDR      r0,[r0,#0]  ; SysTickTimeDelay
000004  b120              CBZ      r0,|L3.16|
;;;64         SysTickTimeDelay--;        // SysTickTimeDelay is a global volatile variable 
000006  4805              LDR      r0,|L3.28|
000008  6800              LDR      r0,[r0,#0]  ; SysTickTimeDelay
00000a  1e40              SUBS     r0,r0,#1
00000c  4903              LDR      r1,|L3.28|
00000e  6008              STR      r0,[r1,#0]  ; SysTickTimeDelay
                  |L3.16|
;;;65     	SysTickCurrenTick++;
000010  4803              LDR      r0,|L3.32|
000012  6800              LDR      r0,[r0,#0]  ; SysTickCurrenTick
000014  1c40              ADDS     r0,r0,#1
000016  4902              LDR      r1,|L3.32|
000018  6008              STR      r0,[r1,#0]  ; SysTickCurrenTick
;;;66     } 	
00001a  4770              BX       lr
;;;67     
                          ENDP

                  |L3.28|
                          DCD      SysTickTimeDelay
                  |L3.32|
                          DCD      SysTickCurrenTick

                          AREA ||i.SysTick_Initialize||, CODE, READONLY, ALIGN=2

                  SysTick_Initialize PROC
;;;17      */
;;;18      void SysTick_Initialize (uint32_t ticks) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;19     //  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
;;;20     //  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
;;;21     //  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
;;;22     //  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
;;;23     
;;;24         SysTick->CTRL = 0;            // Disable SysTick
000004  2000              MOVS     r0,#0
000006  f04f21e0          MOV      r1,#0xe000e000
00000a  6108              STR      r0,[r1,#0x10]
;;;25     
;;;26         SysTick->LOAD = SystemCoreClock/ticks - 1;    // Set reload register
00000c  4815              LDR      r0,|L4.100|
00000e  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000010  fbb0f0f2          UDIV     r0,r0,r2
000014  1e40              SUBS     r0,r0,#1
000016  6148              STR      r0,[r1,#0x14]
;;;27     
;;;28         // Set interrupt priority of SysTick to least urgency (i.e., largest priority value)
;;;29         NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);
000018  1748              ASRS     r0,r1,#29
00001a  210f              MOVS     r1,#0xf
00001c  2800              CMP      r0,#0
00001e  db04              BLT      |L4.42|
000020  070b              LSLS     r3,r1,#28
000022  0e1c              LSRS     r4,r3,#24
000024  4b10              LDR      r3,|L4.104|
000026  541c              STRB     r4,[r3,r0]
000028  e006              B        |L4.56|
                  |L4.42|
00002a  070b              LSLS     r3,r1,#28
00002c  0e1d              LSRS     r5,r3,#24
00002e  4b0f              LDR      r3,|L4.108|
000030  f000040f          AND      r4,r0,#0xf
000034  1f24              SUBS     r4,r4,#4
000036  551d              STRB     r5,[r3,r4]
                  |L4.56|
000038  bf00              NOP      
;;;30     
;;;31         SysTick->VAL = 0;             // Reset the SysTick counter value
00003a  2000              MOVS     r0,#0
00003c  f04f21e0          MOV      r1,#0xe000e000
000040  6188              STR      r0,[r1,#0x18]
;;;32     
;;;33         // Select processor clock: 1 = processor clock; 0 = external clock
;;;34         SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
000042  4608              MOV      r0,r1
000044  6900              LDR      r0,[r0,#0x10]
000046  f0400004          ORR      r0,r0,#4
00004a  6108              STR      r0,[r1,#0x10]
;;;35     
;;;36         // Enables SysTick interrupt, 1 = Enable, 0 = Disable
;;;37         SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk;
00004c  4608              MOV      r0,r1
00004e  6900              LDR      r0,[r0,#0x10]
000050  f0400002          ORR      r0,r0,#2
000054  6108              STR      r0,[r1,#0x10]
;;;38     
;;;39         // Enable SysTick
;;;40         SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
000056  4608              MOV      r0,r1
000058  6900              LDR      r0,[r0,#0x10]
00005a  f0400001          ORR      r0,r0,#1
00005e  6108              STR      r0,[r1,#0x10]
;;;41     }
000060  bd30              POP      {r4,r5,pc}
;;;42     
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
                          DCD      SystemCoreClock
                  |L4.104|
                          DCD      0xe000e400
                  |L4.108|
                          DCD      0xe000ed18

                          AREA ||.data||, DATA, ALIGN=2

                  SysTickTimeDelay
                          DCD      0x00000000
                  SysTickCurrenTick
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Src\\SysTick.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_SysTick_c_b914507a____REV16|
#line 492 "D:\\Users\\Laurent\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___9_SysTick_c_b914507a____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_SysTick_c_b914507a____REVSH|
#line 507
|__asm___9_SysTick_c_b914507a____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___9_SysTick_c_b914507a____RRX|
#line 694
|__asm___9_SysTick_c_b914507a____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
